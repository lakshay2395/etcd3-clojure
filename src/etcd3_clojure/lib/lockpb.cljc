;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; Message Implementation of package lockpb
;;;----------------------------------------------------------------------------------
(ns etcd3-clojure.lib.lockpb
  (:require [protojure.protobuf.protocol :as pb]
            [protojure.protobuf.serdes.core :refer :all]
            [protojure.protobuf.serdes.complex :refer :all]
            [protojure.protobuf.serdes.utils :refer [tag-map]]
            [protojure.protobuf.serdes.stream :as stream]
            [etcd3-clojure.lib.etcdserverpb :as etcdserverpb]
            [clojure.set :as set]
            [clojure.spec.alpha :as s]))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Forward declarations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(declare cis->LockRequest)
(declare ecis->LockRequest)
(declare new-LockRequest)
(declare cis->LockResponse)
(declare ecis->LockResponse)
(declare new-LockResponse)
(declare cis->UnlockRequest)
(declare ecis->UnlockRequest)
(declare new-UnlockRequest)
(declare cis->UnlockResponse)
(declare ecis->UnlockResponse)
(declare new-UnlockResponse)


;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Message Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; LockRequest
;-----------------------------------------------------------------------------
(defrecord LockRequest [name lease]
  pb/Writer

  (serialize [this os]
    (write-Bytes 1  {:optimize true} (:name this) os)
    (write-Int64 2  {:optimize true} (:lease this) os)))

(s/def :lockpb.messages.LockRequest/name bytes?)
(s/def :lockpb.messages.LockRequest/lease int?)
(s/def ::LockRequest-spec (s/keys :opt-un [:lockpb.messages.LockRequest/name :lockpb.messages.LockRequest/lease ]))
(def LockRequest-defaults {:name (byte-array 0) :lease 0 })

(defn cis->LockRequest
  "CodedInputStream to LockRequest"
  [is]
  (->> (tag-map LockRequest-defaults
         (fn [tag index]
             (case index
               1 [:name (cis->Bytes is)]
               2 [:lease (cis->Int64 is)]

               [index (cis->undefined tag is)]))
         is)
        (map->LockRequest)))

(defn ecis->LockRequest
  "Embedded CodedInputStream to LockRequest"
  [is]
  (cis->embedded cis->LockRequest is))

(defn new-LockRequest
  "Creates a new instance from a map, similar to map->LockRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::LockRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::LockRequest-spec init))))]}
  (-> (merge LockRequest-defaults init)
      (map->LockRequest)))

(defn pb->LockRequest
  "Protobuf to LockRequest"
  [input]
  (cis->LockRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; LockResponse
;-----------------------------------------------------------------------------
(defrecord LockResponse [header key]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)
    (write-Bytes 2  {:optimize true} (:key this) os)))

(s/def :lockpb.messages.LockResponse/key bytes?)
(s/def ::LockResponse-spec (s/keys :opt-un [:lockpb.messages.LockResponse/key ]))
(def LockResponse-defaults {:key (byte-array 0) })

(defn cis->LockResponse
  "CodedInputStream to LockResponse"
  [is]
  (->> (tag-map LockResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (etcd3-clojure.lib.etcdserverpb/ecis->ResponseHeader is)]
               2 [:key (cis->Bytes is)]

               [index (cis->undefined tag is)]))
         is)
        (map->LockResponse)))

(defn ecis->LockResponse
  "Embedded CodedInputStream to LockResponse"
  [is]
  (cis->embedded cis->LockResponse is))

(defn new-LockResponse
  "Creates a new instance from a map, similar to map->LockResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::LockResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::LockResponse-spec init))))]}
  (-> (merge LockResponse-defaults init)
      (cond-> (contains? init :header) (update :header etcd3-clojure.lib.etcdserverpb/new-ResponseHeader))
      (map->LockResponse)))

(defn pb->LockResponse
  "Protobuf to LockResponse"
  [input]
  (cis->LockResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; UnlockRequest
;-----------------------------------------------------------------------------
(defrecord UnlockRequest [key]
  pb/Writer

  (serialize [this os]
    (write-Bytes 1  {:optimize true} (:key this) os)))

(s/def :lockpb.messages.UnlockRequest/key bytes?)
(s/def ::UnlockRequest-spec (s/keys :opt-un [:lockpb.messages.UnlockRequest/key ]))
(def UnlockRequest-defaults {:key (byte-array 0) })

(defn cis->UnlockRequest
  "CodedInputStream to UnlockRequest"
  [is]
  (->> (tag-map UnlockRequest-defaults
         (fn [tag index]
             (case index
               1 [:key (cis->Bytes is)]

               [index (cis->undefined tag is)]))
         is)
        (map->UnlockRequest)))

(defn ecis->UnlockRequest
  "Embedded CodedInputStream to UnlockRequest"
  [is]
  (cis->embedded cis->UnlockRequest is))

(defn new-UnlockRequest
  "Creates a new instance from a map, similar to map->UnlockRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::UnlockRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::UnlockRequest-spec init))))]}
  (-> (merge UnlockRequest-defaults init)
      (map->UnlockRequest)))

(defn pb->UnlockRequest
  "Protobuf to UnlockRequest"
  [input]
  (cis->UnlockRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; UnlockResponse
;-----------------------------------------------------------------------------
(defrecord UnlockResponse [header]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)))

(s/def ::UnlockResponse-spec (s/keys :opt-un []))
(def UnlockResponse-defaults {})

(defn cis->UnlockResponse
  "CodedInputStream to UnlockResponse"
  [is]
  (->> (tag-map UnlockResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (etcd3-clojure.lib.etcdserverpb/ecis->ResponseHeader is)]

               [index (cis->undefined tag is)]))
         is)
        (map->UnlockResponse)))

(defn ecis->UnlockResponse
  "Embedded CodedInputStream to UnlockResponse"
  [is]
  (cis->embedded cis->UnlockResponse is))

(defn new-UnlockResponse
  "Creates a new instance from a map, similar to map->UnlockResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::UnlockResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::UnlockResponse-spec init))))]}
  (-> (merge UnlockResponse-defaults init)
      (cond-> (contains? init :header) (update :header etcd3-clojure.lib.etcdserverpb/new-ResponseHeader))
      (map->UnlockResponse)))

(defn pb->UnlockResponse
  "Protobuf to UnlockResponse"
  [input]
  (cis->UnlockResponse (stream/new-cis input)))

