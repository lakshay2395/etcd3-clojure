;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; Message Implementation of package authpb
;;;----------------------------------------------------------------------------------
(ns etcd3-clojure.lib.authpb
  (:require [protojure.protobuf.protocol :as pb]
            [protojure.protobuf.serdes.core :refer :all]
            [protojure.protobuf.serdes.complex :refer :all]
            [protojure.protobuf.serdes.utils :refer [tag-map]]
            [protojure.protobuf.serdes.stream :as stream]
            [clojure.set :as set]
            [clojure.spec.alpha :as s]))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Forward declarations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(declare cis->User)
(declare ecis->User)
(declare new-User)
(declare cis->Permission)
(declare ecis->Permission)
(declare new-Permission)
(declare cis->Role)
(declare ecis->Role)
(declare new-Role)

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Enumerations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; Permission-Type
;-----------------------------------------------------------------------------
(def Permission-Type-val2label {
  0 :read
  1 :write
  2 :readwrite})

(def Permission-Type-label2val (set/map-invert Permission-Type-val2label))

(defn cis->Permission-Type [is]
  (let [val (cis->Enum is)]
    (get Permission-Type-val2label val val)))

(defn- get-Permission-Type [value]
  {:pre [(or (int? value) (contains? Permission-Type-label2val value))]}
  (get Permission-Type-label2val value value))

(defn write-Permission-Type [tag options value os]
  (write-Enum tag options (get-Permission-Type value) os))



;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Message Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; User
;-----------------------------------------------------------------------------
(defrecord User [name password roles]
  pb/Writer

  (serialize [this os]
    (write-Bytes 1  {:optimize true} (:name this) os)
    (write-Bytes 2  {:optimize true} (:password this) os)
    (write-repeated write-String 3 (:roles this) os)))

(s/def :authpb.messages.User/name bytes?)
(s/def :authpb.messages.User/password bytes?)
(s/def :authpb.messages.User/roles (s/every string?))
(s/def ::User-spec (s/keys :opt-un [:authpb.messages.User/name :authpb.messages.User/password :authpb.messages.User/roles ]))
(def User-defaults {:name (byte-array 0) :password (byte-array 0) :roles [] })

(defn cis->User
  "CodedInputStream to User"
  [is]
  (->> (tag-map User-defaults
         (fn [tag index]
             (case index
               1 [:name (cis->Bytes is)]
               2 [:password (cis->Bytes is)]
               3 [:roles (cis->repeated cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->User)))

(defn ecis->User
  "Embedded CodedInputStream to User"
  [is]
  (cis->embedded cis->User is))

(defn new-User
  "Creates a new instance from a map, similar to map->User except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::User-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::User-spec init))))]}
  (-> (merge User-defaults init)
      (map->User)))

(defn pb->User
  "Protobuf to User"
  [input]
  (cis->User (stream/new-cis input)))

;-----------------------------------------------------------------------------
; Permission
;-----------------------------------------------------------------------------
(defrecord Permission [permType key range-end]
  pb/Writer

  (serialize [this os]
    (write-Permission-Type 1  {:optimize true} (:permType this) os)
    (write-Bytes 2  {:optimize true} (:key this) os)
    (write-Bytes 3  {:optimize true} (:range-end this) os)))

(s/def :authpb.messages.Permission/permType (s/or :keyword keyword? :int int?))
(s/def :authpb.messages.Permission/key bytes?)
(s/def :authpb.messages.Permission/range-end bytes?)
(s/def ::Permission-spec (s/keys :opt-un [:authpb.messages.Permission/permType :authpb.messages.Permission/key :authpb.messages.Permission/range-end ]))
(def Permission-defaults {:permType (Permission-Type-val2label 0) :key (byte-array 0) :range-end (byte-array 0) })

(defn cis->Permission
  "CodedInputStream to Permission"
  [is]
  (->> (tag-map Permission-defaults
         (fn [tag index]
             (case index
               1 [:permType (cis->Permission-Type is)]
               2 [:key (cis->Bytes is)]
               3 [:range-end (cis->Bytes is)]

               [index (cis->undefined tag is)]))
         is)
        (map->Permission)))

(defn ecis->Permission
  "Embedded CodedInputStream to Permission"
  [is]
  (cis->embedded cis->Permission is))

(defn new-Permission
  "Creates a new instance from a map, similar to map->Permission except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Permission-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Permission-spec init))))]}
  (-> (merge Permission-defaults init)
      (map->Permission)))

(defn pb->Permission
  "Protobuf to Permission"
  [input]
  (cis->Permission (stream/new-cis input)))

;-----------------------------------------------------------------------------
; Role
;-----------------------------------------------------------------------------
(defrecord Role [name keyPermission]
  pb/Writer

  (serialize [this os]
    (write-Bytes 1  {:optimize true} (:name this) os)
    (write-repeated write-embedded 2 (:keyPermission this) os)))

(s/def :authpb.messages.Role/name bytes?)

(s/def ::Role-spec (s/keys :opt-un [:authpb.messages.Role/name ]))
(def Role-defaults {:name (byte-array 0) :keyPermission [] })

(defn cis->Role
  "CodedInputStream to Role"
  [is]
  (->> (tag-map Role-defaults
         (fn [tag index]
             (case index
               1 [:name (cis->Bytes is)]
               2 [:keyPermission (cis->repeated ecis->Permission is)]

               [index (cis->undefined tag is)]))
         is)
        (map->Role)))

(defn ecis->Role
  "Embedded CodedInputStream to Role"
  [is]
  (cis->embedded cis->Role is))

(defn new-Role
  "Creates a new instance from a map, similar to map->Role except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Role-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Role-spec init))))]}
  (-> (merge Role-defaults init)
      (cond-> (contains? init :keyPermission) (update :keyPermission #(map new-Permission %)))
      (map->Role)))

(defn pb->Role
  "Protobuf to Role"
  [input]
  (cis->Role (stream/new-cis input)))

