;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; Message Implementation of package etcdserverpb
;;;----------------------------------------------------------------------------------
(ns etcd3-clojure.lib.etcdserverpb
  (:require [protojure.protobuf.protocol :as pb]
            [protojure.protobuf.serdes.core :refer :all]
            [protojure.protobuf.serdes.complex :refer :all]
            [protojure.protobuf.serdes.utils :refer [tag-map]]
            [protojure.protobuf.serdes.stream :as stream]
            [etcd3-clojure.lib.authpb :as authpb]
            [etcd3-clojure.lib.mvccpb :as mvccpb]
            [clojure.set :as set]
            [clojure.spec.alpha :as s]))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Forward declarations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(declare cis->AuthUserRevokeRoleRequest)
(declare ecis->AuthUserRevokeRoleRequest)
(declare new-AuthUserRevokeRoleRequest)
(declare cis->HashRequest)
(declare ecis->HashRequest)
(declare new-HashRequest)
(declare cis->WatchCancelRequest)
(declare ecis->WatchCancelRequest)
(declare new-WatchCancelRequest)
(declare cis->AuthUserListResponse)
(declare ecis->AuthUserListResponse)
(declare new-AuthUserListResponse)
(declare cis->AuthUserAddRequest)
(declare ecis->AuthUserAddRequest)
(declare new-AuthUserAddRequest)
(declare cis->AlarmResponse)
(declare ecis->AlarmResponse)
(declare new-AlarmResponse)
(declare cis->StatusResponse)
(declare ecis->StatusResponse)
(declare new-StatusResponse)
(declare cis->MemberUpdateResponse)
(declare ecis->MemberUpdateResponse)
(declare new-MemberUpdateResponse)
(declare cis->CompactionRequest)
(declare ecis->CompactionRequest)
(declare new-CompactionRequest)
(declare cis->MemberListRequest)
(declare ecis->MemberListRequest)
(declare new-MemberListRequest)
(declare cis->ResponseOp)
(declare ecis->ResponseOp)
(declare new-ResponseOp)
(declare cis->MemberAddRequest)
(declare ecis->MemberAddRequest)
(declare new-MemberAddRequest)
(declare cis->HashKVResponse)
(declare ecis->HashKVResponse)
(declare new-HashKVResponse)
(declare cis->AuthUserDeleteRequest)
(declare ecis->AuthUserDeleteRequest)
(declare new-AuthUserDeleteRequest)
(declare cis->AlarmRequest)
(declare ecis->AlarmRequest)
(declare new-AlarmRequest)
(declare cis->MoveLeaderResponse)
(declare ecis->MoveLeaderResponse)
(declare new-MoveLeaderResponse)
(declare cis->DeleteRangeResponse)
(declare ecis->DeleteRangeResponse)
(declare new-DeleteRangeResponse)
(declare cis->WatchRequest)
(declare ecis->WatchRequest)
(declare new-WatchRequest)
(declare cis->LeaseGrantRequest)
(declare ecis->LeaseGrantRequest)
(declare new-LeaseGrantRequest)
(declare cis->LeaseGrantResponse)
(declare ecis->LeaseGrantResponse)
(declare new-LeaseGrantResponse)
(declare cis->MemberUpdateRequest)
(declare ecis->MemberUpdateRequest)
(declare new-MemberUpdateRequest)
(declare cis->AuthUserChangePasswordRequest)
(declare ecis->AuthUserChangePasswordRequest)
(declare new-AuthUserChangePasswordRequest)
(declare cis->AuthRoleDeleteResponse)
(declare ecis->AuthRoleDeleteResponse)
(declare new-AuthRoleDeleteResponse)
(declare cis->AuthenticateRequest)
(declare ecis->AuthenticateRequest)
(declare new-AuthenticateRequest)
(declare cis->Member)
(declare ecis->Member)
(declare new-Member)
(declare cis->AuthUserGetRequest)
(declare ecis->AuthUserGetRequest)
(declare new-AuthUserGetRequest)
(declare cis->AlarmMember)
(declare ecis->AlarmMember)
(declare new-AlarmMember)
(declare cis->AuthRoleDeleteRequest)
(declare ecis->AuthRoleDeleteRequest)
(declare new-AuthRoleDeleteRequest)
(declare cis->AuthRoleListResponse)
(declare ecis->AuthRoleListResponse)
(declare new-AuthRoleListResponse)
(declare cis->CompactionResponse)
(declare ecis->CompactionResponse)
(declare new-CompactionResponse)
(declare cis->WatchCreateRequest)
(declare ecis->WatchCreateRequest)
(declare new-WatchCreateRequest)
(declare cis->AuthUserGrantRoleResponse)
(declare ecis->AuthUserGrantRoleResponse)
(declare new-AuthUserGrantRoleResponse)
(declare cis->AuthRoleGrantPermissionRequest)
(declare ecis->AuthRoleGrantPermissionRequest)
(declare new-AuthRoleGrantPermissionRequest)
(declare cis->RangeResponse)
(declare ecis->RangeResponse)
(declare new-RangeResponse)
(declare cis->PutResponse)
(declare ecis->PutResponse)
(declare new-PutResponse)
(declare cis->MemberRemoveResponse)
(declare ecis->MemberRemoveResponse)
(declare new-MemberRemoveResponse)
(declare cis->LeaseTimeToLiveRequest)
(declare ecis->LeaseTimeToLiveRequest)
(declare new-LeaseTimeToLiveRequest)
(declare cis->DefragmentRequest)
(declare ecis->DefragmentRequest)
(declare new-DefragmentRequest)
(declare cis->AuthUserRevokeRoleResponse)
(declare ecis->AuthUserRevokeRoleResponse)
(declare new-AuthUserRevokeRoleResponse)
(declare cis->DeleteRangeRequest)
(declare ecis->DeleteRangeRequest)
(declare new-DeleteRangeRequest)
(declare cis->ResponseHeader)
(declare ecis->ResponseHeader)
(declare new-ResponseHeader)
(declare cis->SnapshotRequest)
(declare ecis->SnapshotRequest)
(declare new-SnapshotRequest)
(declare cis->AuthUserAddResponse)
(declare ecis->AuthUserAddResponse)
(declare new-AuthUserAddResponse)
(declare cis->RangeRequest)
(declare ecis->RangeRequest)
(declare new-RangeRequest)
(declare cis->AuthenticateResponse)
(declare ecis->AuthenticateResponse)
(declare new-AuthenticateResponse)
(declare cis->DefragmentResponse)
(declare ecis->DefragmentResponse)
(declare new-DefragmentResponse)
(declare cis->LeaseKeepAliveResponse)
(declare ecis->LeaseKeepAliveResponse)
(declare new-LeaseKeepAliveResponse)
(declare cis->MemberAddResponse)
(declare ecis->MemberAddResponse)
(declare new-MemberAddResponse)
(declare cis->TxnResponse)
(declare ecis->TxnResponse)
(declare new-TxnResponse)
(declare cis->LeaseRevokeRequest)
(declare ecis->LeaseRevokeRequest)
(declare new-LeaseRevokeRequest)
(declare cis->MoveLeaderRequest)
(declare ecis->MoveLeaderRequest)
(declare new-MoveLeaderRequest)
(declare cis->AuthRoleGrantPermissionResponse)
(declare ecis->AuthRoleGrantPermissionResponse)
(declare new-AuthRoleGrantPermissionResponse)
(declare cis->LeaseKeepAliveRequest)
(declare ecis->LeaseKeepAliveRequest)
(declare new-LeaseKeepAliveRequest)
(declare cis->HashResponse)
(declare ecis->HashResponse)
(declare new-HashResponse)
(declare cis->LeaseTimeToLiveResponse)
(declare ecis->LeaseTimeToLiveResponse)
(declare new-LeaseTimeToLiveResponse)
(declare cis->PutRequest)
(declare ecis->PutRequest)
(declare new-PutRequest)
(declare cis->AuthRoleListRequest)
(declare ecis->AuthRoleListRequest)
(declare new-AuthRoleListRequest)
(declare cis->AuthDisableResponse)
(declare ecis->AuthDisableResponse)
(declare new-AuthDisableResponse)
(declare cis->AuthEnableResponse)
(declare ecis->AuthEnableResponse)
(declare new-AuthEnableResponse)
(declare cis->TxnRequest)
(declare ecis->TxnRequest)
(declare new-TxnRequest)
(declare cis->StatusRequest)
(declare ecis->StatusRequest)
(declare new-StatusRequest)
(declare cis->AuthRoleRevokePermissionResponse)
(declare ecis->AuthRoleRevokePermissionResponse)
(declare new-AuthRoleRevokePermissionResponse)
(declare cis->AuthEnableRequest)
(declare ecis->AuthEnableRequest)
(declare new-AuthEnableRequest)
(declare cis->MemberListResponse)
(declare ecis->MemberListResponse)
(declare new-MemberListResponse)
(declare cis->AuthRoleAddRequest)
(declare ecis->AuthRoleAddRequest)
(declare new-AuthRoleAddRequest)
(declare cis->Compare)
(declare ecis->Compare)
(declare new-Compare)
(declare cis->AuthRoleAddResponse)
(declare ecis->AuthRoleAddResponse)
(declare new-AuthRoleAddResponse)
(declare cis->MemberRemoveRequest)
(declare ecis->MemberRemoveRequest)
(declare new-MemberRemoveRequest)
(declare cis->RequestOp)
(declare ecis->RequestOp)
(declare new-RequestOp)
(declare cis->AuthRoleGetResponse)
(declare ecis->AuthRoleGetResponse)
(declare new-AuthRoleGetResponse)
(declare cis->SnapshotResponse)
(declare ecis->SnapshotResponse)
(declare new-SnapshotResponse)
(declare cis->AuthUserListRequest)
(declare ecis->AuthUserListRequest)
(declare new-AuthUserListRequest)
(declare cis->LeaseRevokeResponse)
(declare ecis->LeaseRevokeResponse)
(declare new-LeaseRevokeResponse)
(declare cis->AuthRoleGetRequest)
(declare ecis->AuthRoleGetRequest)
(declare new-AuthRoleGetRequest)
(declare cis->HashKVRequest)
(declare ecis->HashKVRequest)
(declare new-HashKVRequest)
(declare cis->AuthDisableRequest)
(declare ecis->AuthDisableRequest)
(declare new-AuthDisableRequest)
(declare cis->AuthUserGetResponse)
(declare ecis->AuthUserGetResponse)
(declare new-AuthUserGetResponse)
(declare cis->AuthUserGrantRoleRequest)
(declare ecis->AuthUserGrantRoleRequest)
(declare new-AuthUserGrantRoleRequest)
(declare cis->AuthUserChangePasswordResponse)
(declare ecis->AuthUserChangePasswordResponse)
(declare new-AuthUserChangePasswordResponse)
(declare cis->WatchResponse)
(declare ecis->WatchResponse)
(declare new-WatchResponse)
(declare cis->AuthUserDeleteResponse)
(declare ecis->AuthUserDeleteResponse)
(declare new-AuthUserDeleteResponse)
(declare cis->AuthRoleRevokePermissionRequest)
(declare ecis->AuthRoleRevokePermissionRequest)
(declare new-AuthRoleRevokePermissionRequest)

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Enumerations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; AlarmType
;-----------------------------------------------------------------------------
(def AlarmType-val2label {
  0 :none
  1 :nospace})

(def AlarmType-label2val (set/map-invert AlarmType-val2label))

(defn cis->AlarmType [is]
  (let [val (cis->Enum is)]
    (get AlarmType-val2label val val)))

(defn- get-AlarmType [value]
  {:pre [(or (int? value) (contains? AlarmType-label2val value))]}
  (get AlarmType-label2val value value))

(defn write-AlarmType [tag options value os]
  (write-Enum tag options (get-AlarmType value) os))

;-----------------------------------------------------------------------------
; RangeRequest-SortOrder
;-----------------------------------------------------------------------------
(def RangeRequest-SortOrder-val2label {
  0 :none
  1 :ascend
  2 :descend})

(def RangeRequest-SortOrder-label2val (set/map-invert RangeRequest-SortOrder-val2label))

(defn cis->RangeRequest-SortOrder [is]
  (let [val (cis->Enum is)]
    (get RangeRequest-SortOrder-val2label val val)))

(defn- get-RangeRequest-SortOrder [value]
  {:pre [(or (int? value) (contains? RangeRequest-SortOrder-label2val value))]}
  (get RangeRequest-SortOrder-label2val value value))

(defn write-RangeRequest-SortOrder [tag options value os]
  (write-Enum tag options (get-RangeRequest-SortOrder value) os))

;-----------------------------------------------------------------------------
; RangeRequest-SortTarget
;-----------------------------------------------------------------------------
(def RangeRequest-SortTarget-val2label {
  0 :key
  1 :version
  2 :create
  3 :mod
  4 :value})

(def RangeRequest-SortTarget-label2val (set/map-invert RangeRequest-SortTarget-val2label))

(defn cis->RangeRequest-SortTarget [is]
  (let [val (cis->Enum is)]
    (get RangeRequest-SortTarget-val2label val val)))

(defn- get-RangeRequest-SortTarget [value]
  {:pre [(or (int? value) (contains? RangeRequest-SortTarget-label2val value))]}
  (get RangeRequest-SortTarget-label2val value value))

(defn write-RangeRequest-SortTarget [tag options value os]
  (write-Enum tag options (get-RangeRequest-SortTarget value) os))

;-----------------------------------------------------------------------------
; Compare-CompareResult
;-----------------------------------------------------------------------------
(def Compare-CompareResult-val2label {
  0 :equal
  1 :greater
  2 :less
  3 :not-equal})

(def Compare-CompareResult-label2val (set/map-invert Compare-CompareResult-val2label))

(defn cis->Compare-CompareResult [is]
  (let [val (cis->Enum is)]
    (get Compare-CompareResult-val2label val val)))

(defn- get-Compare-CompareResult [value]
  {:pre [(or (int? value) (contains? Compare-CompareResult-label2val value))]}
  (get Compare-CompareResult-label2val value value))

(defn write-Compare-CompareResult [tag options value os]
  (write-Enum tag options (get-Compare-CompareResult value) os))

;-----------------------------------------------------------------------------
; Compare-CompareTarget
;-----------------------------------------------------------------------------
(def Compare-CompareTarget-val2label {
  0 :version
  1 :create
  2 :mod
  3 :value})

(def Compare-CompareTarget-label2val (set/map-invert Compare-CompareTarget-val2label))

(defn cis->Compare-CompareTarget [is]
  (let [val (cis->Enum is)]
    (get Compare-CompareTarget-val2label val val)))

(defn- get-Compare-CompareTarget [value]
  {:pre [(or (int? value) (contains? Compare-CompareTarget-label2val value))]}
  (get Compare-CompareTarget-label2val value value))

(defn write-Compare-CompareTarget [tag options value os]
  (write-Enum tag options (get-Compare-CompareTarget value) os))

;-----------------------------------------------------------------------------
; WatchCreateRequest-FilterType
;-----------------------------------------------------------------------------
(def WatchCreateRequest-FilterType-val2label {
  0 :noput
  1 :nodelete})

(def WatchCreateRequest-FilterType-label2val (set/map-invert WatchCreateRequest-FilterType-val2label))

(defn cis->WatchCreateRequest-FilterType [is]
  (let [val (cis->Enum is)]
    (get WatchCreateRequest-FilterType-val2label val val)))

(defn- get-WatchCreateRequest-FilterType [value]
  {:pre [(or (int? value) (contains? WatchCreateRequest-FilterType-label2val value))]}
  (get WatchCreateRequest-FilterType-label2val value value))

(defn write-WatchCreateRequest-FilterType [tag options value os]
  (write-Enum tag options (get-WatchCreateRequest-FilterType value) os))

;-----------------------------------------------------------------------------
; AlarmRequest-AlarmAction
;-----------------------------------------------------------------------------
(def AlarmRequest-AlarmAction-val2label {
  0 :get
  1 :activate
  2 :deactivate})

(def AlarmRequest-AlarmAction-label2val (set/map-invert AlarmRequest-AlarmAction-val2label))

(defn cis->AlarmRequest-AlarmAction [is]
  (let [val (cis->Enum is)]
    (get AlarmRequest-AlarmAction-val2label val val)))

(defn- get-AlarmRequest-AlarmAction [value]
  {:pre [(or (int? value) (contains? AlarmRequest-AlarmAction-label2val value))]}
  (get AlarmRequest-AlarmAction-label2val value value))

(defn write-AlarmRequest-AlarmAction [tag options value os]
  (write-Enum tag options (get-AlarmRequest-AlarmAction value) os))


;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; response's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-response [origkeyval]
  (cond
     (get-in origkeyval [:response :response-range]) (update-in origkeyval [:response :response-range] new-RangeResponse)
     (get-in origkeyval [:response :response-put]) (update-in origkeyval [:response :response-put] new-PutResponse)
     (get-in origkeyval [:response :response-delete-range]) (update-in origkeyval [:response :response-delete-range] new-DeleteRangeResponse)
     (get-in origkeyval [:response :response-txn]) (update-in origkeyval [:response :response-txn] new-TxnResponse)
     :default origkeyval))

(defn write-response [response os]
  (let [field (first response)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
     (case k
         :response-range (write-embedded 1 v os)
         :response-put (write-embedded 2 v os)
         :response-delete-range (write-embedded 3 v os)
         :response-txn (write-embedded 4 v os)
         nil)))


;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; request-union's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-request-union [origkeyval]
  (cond
     (get-in origkeyval [:request-union :create-request]) (update-in origkeyval [:request-union :create-request] new-WatchCreateRequest)
     (get-in origkeyval [:request-union :cancel-request]) (update-in origkeyval [:request-union :cancel-request] new-WatchCancelRequest)
     :default origkeyval))

(defn write-request-union [request-union os]
  (let [field (first request-union)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
     (case k
         :create-request (write-embedded 1 v os)
         :cancel-request (write-embedded 2 v os)
         nil)))


;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; target-union's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-target-union [origkeyval]
  (cond
     (get-in origkeyval [:target-union :version]) origkeyval
     (get-in origkeyval [:target-union :create-revision]) origkeyval
     (get-in origkeyval [:target-union :mod-revision]) origkeyval
     (get-in origkeyval [:target-union :value]) origkeyval
     :default origkeyval))

(defn write-target-union [target-union os]
  (let [field (first target-union)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
     (case k
         :version (write-Int64 4  {:optimize false} v os)
         :create-revision (write-Int64 5  {:optimize false} v os)
         :mod-revision (write-Int64 6  {:optimize false} v os)
         :value (write-Bytes 7  {:optimize false} v os)
         nil)))


;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; request's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-request [origkeyval]
  (cond
     (get-in origkeyval [:request :request-range]) (update-in origkeyval [:request :request-range] new-RangeRequest)
     (get-in origkeyval [:request :request-put]) (update-in origkeyval [:request :request-put] new-PutRequest)
     (get-in origkeyval [:request :request-delete-range]) (update-in origkeyval [:request :request-delete-range] new-DeleteRangeRequest)
     (get-in origkeyval [:request :request-txn]) (update-in origkeyval [:request :request-txn] new-TxnRequest)
     :default origkeyval))

(defn write-request [request os]
  (let [field (first request)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
     (case k
         :request-range (write-embedded 1 v os)
         :request-put (write-embedded 2 v os)
         :request-delete-range (write-embedded 3 v os)
         :request-txn (write-embedded 4 v os)
         nil)))



;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Message Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; AuthUserRevokeRoleRequest
;-----------------------------------------------------------------------------
(defrecord AuthUserRevokeRoleRequest [name role]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:name this) os)
    (write-String 2  {:optimize true} (:role this) os)))

(s/def :etcdserverpb.messages.AuthUserRevokeRoleRequest/name string?)
(s/def :etcdserverpb.messages.AuthUserRevokeRoleRequest/role string?)
(s/def ::AuthUserRevokeRoleRequest-spec (s/keys :opt-un [:etcdserverpb.messages.AuthUserRevokeRoleRequest/name :etcdserverpb.messages.AuthUserRevokeRoleRequest/role ]))
(def AuthUserRevokeRoleRequest-defaults {:name "" :role "" })

(defn cis->AuthUserRevokeRoleRequest
  "CodedInputStream to AuthUserRevokeRoleRequest"
  [is]
  (->> (tag-map AuthUserRevokeRoleRequest-defaults
         (fn [tag index]
             (case index
               1 [:name (cis->String is)]
               2 [:role (cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthUserRevokeRoleRequest)))

(defn ecis->AuthUserRevokeRoleRequest
  "Embedded CodedInputStream to AuthUserRevokeRoleRequest"
  [is]
  (cis->embedded cis->AuthUserRevokeRoleRequest is))

(defn new-AuthUserRevokeRoleRequest
  "Creates a new instance from a map, similar to map->AuthUserRevokeRoleRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthUserRevokeRoleRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthUserRevokeRoleRequest-spec init))))]}
  (-> (merge AuthUserRevokeRoleRequest-defaults init)
      (map->AuthUserRevokeRoleRequest)))

(defn pb->AuthUserRevokeRoleRequest
  "Protobuf to AuthUserRevokeRoleRequest"
  [input]
  (cis->AuthUserRevokeRoleRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; HashRequest
;-----------------------------------------------------------------------------
(defrecord HashRequest []
  pb/Writer

  (serialize [this os]
))

(s/def ::HashRequest-spec (s/keys :opt-un []))
(def HashRequest-defaults {})

(defn cis->HashRequest
  "CodedInputStream to HashRequest"
  [is]
  (->> (tag-map HashRequest-defaults
         (fn [tag index]
             (case index
               [index (cis->undefined tag is)]))
         is)
        (map->HashRequest)))

(defn ecis->HashRequest
  "Embedded CodedInputStream to HashRequest"
  [is]
  (cis->embedded cis->HashRequest is))

(defn new-HashRequest
  "Creates a new instance from a map, similar to map->HashRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::HashRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::HashRequest-spec init))))]}
  (-> (merge HashRequest-defaults init)
      (map->HashRequest)))

(defn pb->HashRequest
  "Protobuf to HashRequest"
  [input]
  (cis->HashRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; WatchCancelRequest
;-----------------------------------------------------------------------------
(defrecord WatchCancelRequest [watch-id]
  pb/Writer

  (serialize [this os]
    (write-Int64 1  {:optimize true} (:watch-id this) os)))

(s/def :etcdserverpb.messages.WatchCancelRequest/watch-id int?)
(s/def ::WatchCancelRequest-spec (s/keys :opt-un [:etcdserverpb.messages.WatchCancelRequest/watch-id ]))
(def WatchCancelRequest-defaults {:watch-id 0 })

(defn cis->WatchCancelRequest
  "CodedInputStream to WatchCancelRequest"
  [is]
  (->> (tag-map WatchCancelRequest-defaults
         (fn [tag index]
             (case index
               1 [:watch-id (cis->Int64 is)]

               [index (cis->undefined tag is)]))
         is)
        (map->WatchCancelRequest)))

(defn ecis->WatchCancelRequest
  "Embedded CodedInputStream to WatchCancelRequest"
  [is]
  (cis->embedded cis->WatchCancelRequest is))

(defn new-WatchCancelRequest
  "Creates a new instance from a map, similar to map->WatchCancelRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::WatchCancelRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::WatchCancelRequest-spec init))))]}
  (-> (merge WatchCancelRequest-defaults init)
      (map->WatchCancelRequest)))

(defn pb->WatchCancelRequest
  "Protobuf to WatchCancelRequest"
  [input]
  (cis->WatchCancelRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthUserListResponse
;-----------------------------------------------------------------------------
(defrecord AuthUserListResponse [header users]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)
    (write-repeated write-String 2 (:users this) os)))

(s/def :etcdserverpb.messages.AuthUserListResponse/users (s/every string?))
(s/def ::AuthUserListResponse-spec (s/keys :opt-un [:etcdserverpb.messages.AuthUserListResponse/users ]))
(def AuthUserListResponse-defaults {:users [] })

(defn cis->AuthUserListResponse
  "CodedInputStream to AuthUserListResponse"
  [is]
  (->> (tag-map AuthUserListResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]
               2 [:users (cis->repeated cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthUserListResponse)))

(defn ecis->AuthUserListResponse
  "Embedded CodedInputStream to AuthUserListResponse"
  [is]
  (cis->embedded cis->AuthUserListResponse is))

(defn new-AuthUserListResponse
  "Creates a new instance from a map, similar to map->AuthUserListResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthUserListResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthUserListResponse-spec init))))]}
  (-> (merge AuthUserListResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (map->AuthUserListResponse)))

(defn pb->AuthUserListResponse
  "Protobuf to AuthUserListResponse"
  [input]
  (cis->AuthUserListResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthUserAddRequest
;-----------------------------------------------------------------------------
(defrecord AuthUserAddRequest [name password]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:name this) os)
    (write-String 2  {:optimize true} (:password this) os)))

(s/def :etcdserverpb.messages.AuthUserAddRequest/name string?)
(s/def :etcdserverpb.messages.AuthUserAddRequest/password string?)
(s/def ::AuthUserAddRequest-spec (s/keys :opt-un [:etcdserverpb.messages.AuthUserAddRequest/name :etcdserverpb.messages.AuthUserAddRequest/password ]))
(def AuthUserAddRequest-defaults {:name "" :password "" })

(defn cis->AuthUserAddRequest
  "CodedInputStream to AuthUserAddRequest"
  [is]
  (->> (tag-map AuthUserAddRequest-defaults
         (fn [tag index]
             (case index
               1 [:name (cis->String is)]
               2 [:password (cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthUserAddRequest)))

(defn ecis->AuthUserAddRequest
  "Embedded CodedInputStream to AuthUserAddRequest"
  [is]
  (cis->embedded cis->AuthUserAddRequest is))

(defn new-AuthUserAddRequest
  "Creates a new instance from a map, similar to map->AuthUserAddRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthUserAddRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthUserAddRequest-spec init))))]}
  (-> (merge AuthUserAddRequest-defaults init)
      (map->AuthUserAddRequest)))

(defn pb->AuthUserAddRequest
  "Protobuf to AuthUserAddRequest"
  [input]
  (cis->AuthUserAddRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AlarmResponse
;-----------------------------------------------------------------------------
(defrecord AlarmResponse [header alarms]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)
    (write-repeated write-embedded 2 (:alarms this) os)))

(s/def ::AlarmResponse-spec (s/keys :opt-un []))
(def AlarmResponse-defaults {:alarms [] })

(defn cis->AlarmResponse
  "CodedInputStream to AlarmResponse"
  [is]
  (->> (tag-map AlarmResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]
               2 [:alarms (cis->repeated ecis->AlarmMember is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AlarmResponse)))

(defn ecis->AlarmResponse
  "Embedded CodedInputStream to AlarmResponse"
  [is]
  (cis->embedded cis->AlarmResponse is))

(defn new-AlarmResponse
  "Creates a new instance from a map, similar to map->AlarmResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AlarmResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AlarmResponse-spec init))))]}
  (-> (merge AlarmResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (cond-> (contains? init :alarms) (update :alarms #(map new-AlarmMember %)))
      (map->AlarmResponse)))

(defn pb->AlarmResponse
  "Protobuf to AlarmResponse"
  [input]
  (cis->AlarmResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; StatusResponse
;-----------------------------------------------------------------------------
(defrecord StatusResponse [header version dbSize leader raftIndex raftTerm]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)
    (write-String 2  {:optimize true} (:version this) os)
    (write-Int64 3  {:optimize true} (:dbSize this) os)
    (write-UInt64 4  {:optimize true} (:leader this) os)
    (write-UInt64 5  {:optimize true} (:raftIndex this) os)
    (write-UInt64 6  {:optimize true} (:raftTerm this) os)))

(s/def :etcdserverpb.messages.StatusResponse/version string?)
(s/def :etcdserverpb.messages.StatusResponse/dbSize int?)
(s/def :etcdserverpb.messages.StatusResponse/leader int?)
(s/def :etcdserverpb.messages.StatusResponse/raftIndex int?)
(s/def :etcdserverpb.messages.StatusResponse/raftTerm int?)
(s/def ::StatusResponse-spec (s/keys :opt-un [:etcdserverpb.messages.StatusResponse/version :etcdserverpb.messages.StatusResponse/dbSize :etcdserverpb.messages.StatusResponse/leader :etcdserverpb.messages.StatusResponse/raftIndex :etcdserverpb.messages.StatusResponse/raftTerm ]))
(def StatusResponse-defaults {:version "" :dbSize 0 :leader 0 :raftIndex 0 :raftTerm 0 })

(defn cis->StatusResponse
  "CodedInputStream to StatusResponse"
  [is]
  (->> (tag-map StatusResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]
               2 [:version (cis->String is)]
               3 [:dbSize (cis->Int64 is)]
               4 [:leader (cis->UInt64 is)]
               5 [:raftIndex (cis->UInt64 is)]
               6 [:raftTerm (cis->UInt64 is)]

               [index (cis->undefined tag is)]))
         is)
        (map->StatusResponse)))

(defn ecis->StatusResponse
  "Embedded CodedInputStream to StatusResponse"
  [is]
  (cis->embedded cis->StatusResponse is))

(defn new-StatusResponse
  "Creates a new instance from a map, similar to map->StatusResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::StatusResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::StatusResponse-spec init))))]}
  (-> (merge StatusResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (map->StatusResponse)))

(defn pb->StatusResponse
  "Protobuf to StatusResponse"
  [input]
  (cis->StatusResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; MemberUpdateResponse
;-----------------------------------------------------------------------------
(defrecord MemberUpdateResponse [header members]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)
    (write-repeated write-embedded 2 (:members this) os)))

(s/def ::MemberUpdateResponse-spec (s/keys :opt-un []))
(def MemberUpdateResponse-defaults {:members [] })

(defn cis->MemberUpdateResponse
  "CodedInputStream to MemberUpdateResponse"
  [is]
  (->> (tag-map MemberUpdateResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]
               2 [:members (cis->repeated ecis->Member is)]

               [index (cis->undefined tag is)]))
         is)
        (map->MemberUpdateResponse)))

(defn ecis->MemberUpdateResponse
  "Embedded CodedInputStream to MemberUpdateResponse"
  [is]
  (cis->embedded cis->MemberUpdateResponse is))

(defn new-MemberUpdateResponse
  "Creates a new instance from a map, similar to map->MemberUpdateResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::MemberUpdateResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::MemberUpdateResponse-spec init))))]}
  (-> (merge MemberUpdateResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (cond-> (contains? init :members) (update :members #(map new-Member %)))
      (map->MemberUpdateResponse)))

(defn pb->MemberUpdateResponse
  "Protobuf to MemberUpdateResponse"
  [input]
  (cis->MemberUpdateResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; CompactionRequest
;-----------------------------------------------------------------------------
(defrecord CompactionRequest [revision physical]
  pb/Writer

  (serialize [this os]
    (write-Int64 1  {:optimize true} (:revision this) os)
    (write-Bool 2  {:optimize true} (:physical this) os)))

(s/def :etcdserverpb.messages.CompactionRequest/revision int?)
(s/def :etcdserverpb.messages.CompactionRequest/physical boolean?)
(s/def ::CompactionRequest-spec (s/keys :opt-un [:etcdserverpb.messages.CompactionRequest/revision :etcdserverpb.messages.CompactionRequest/physical ]))
(def CompactionRequest-defaults {:revision 0 :physical false })

(defn cis->CompactionRequest
  "CodedInputStream to CompactionRequest"
  [is]
  (->> (tag-map CompactionRequest-defaults
         (fn [tag index]
             (case index
               1 [:revision (cis->Int64 is)]
               2 [:physical (cis->Bool is)]

               [index (cis->undefined tag is)]))
         is)
        (map->CompactionRequest)))

(defn ecis->CompactionRequest
  "Embedded CodedInputStream to CompactionRequest"
  [is]
  (cis->embedded cis->CompactionRequest is))

(defn new-CompactionRequest
  "Creates a new instance from a map, similar to map->CompactionRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::CompactionRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::CompactionRequest-spec init))))]}
  (-> (merge CompactionRequest-defaults init)
      (map->CompactionRequest)))

(defn pb->CompactionRequest
  "Protobuf to CompactionRequest"
  [input]
  (cis->CompactionRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; MemberListRequest
;-----------------------------------------------------------------------------
(defrecord MemberListRequest []
  pb/Writer

  (serialize [this os]
))

(s/def ::MemberListRequest-spec (s/keys :opt-un []))
(def MemberListRequest-defaults {})

(defn cis->MemberListRequest
  "CodedInputStream to MemberListRequest"
  [is]
  (->> (tag-map MemberListRequest-defaults
         (fn [tag index]
             (case index
               [index (cis->undefined tag is)]))
         is)
        (map->MemberListRequest)))

(defn ecis->MemberListRequest
  "Embedded CodedInputStream to MemberListRequest"
  [is]
  (cis->embedded cis->MemberListRequest is))

(defn new-MemberListRequest
  "Creates a new instance from a map, similar to map->MemberListRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::MemberListRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::MemberListRequest-spec init))))]}
  (-> (merge MemberListRequest-defaults init)
      (map->MemberListRequest)))

(defn pb->MemberListRequest
  "Protobuf to MemberListRequest"
  [input]
  (cis->MemberListRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; ResponseOp
;-----------------------------------------------------------------------------
(defrecord ResponseOp [response]
  pb/Writer

  (serialize [this os]
    (write-response  (:response this) os)))

(s/def ::ResponseOp-spec (s/keys :opt-un []))
(def ResponseOp-defaults {})

(defn cis->ResponseOp
  "CodedInputStream to ResponseOp"
  [is]
  (->> (tag-map ResponseOp-defaults
         (fn [tag index]
             (case index
               1 [:response {:response-range (ecis->RangeResponse is)}]
               2 [:response {:response-put (ecis->PutResponse is)}]
               3 [:response {:response-delete-range (ecis->DeleteRangeResponse is)}]
               4 [:response {:response-txn (ecis->TxnResponse is)}]

               [index (cis->undefined tag is)]))
         is)
        (map->ResponseOp)))

(defn ecis->ResponseOp
  "Embedded CodedInputStream to ResponseOp"
  [is]
  (cis->embedded cis->ResponseOp is))

(defn new-ResponseOp
  "Creates a new instance from a map, similar to map->ResponseOp except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ResponseOp-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ResponseOp-spec init))))]}
  (-> (merge ResponseOp-defaults init)
      (convert-response)
      (map->ResponseOp)))

(defn pb->ResponseOp
  "Protobuf to ResponseOp"
  [input]
  (cis->ResponseOp (stream/new-cis input)))

;-----------------------------------------------------------------------------
; MemberAddRequest
;-----------------------------------------------------------------------------
(defrecord MemberAddRequest [peerURLs]
  pb/Writer

  (serialize [this os]
    (write-repeated write-String 1 (:peerURLs this) os)))

(s/def :etcdserverpb.messages.MemberAddRequest/peerURLs (s/every string?))
(s/def ::MemberAddRequest-spec (s/keys :opt-un [:etcdserverpb.messages.MemberAddRequest/peerURLs ]))
(def MemberAddRequest-defaults {:peerURLs [] })

(defn cis->MemberAddRequest
  "CodedInputStream to MemberAddRequest"
  [is]
  (->> (tag-map MemberAddRequest-defaults
         (fn [tag index]
             (case index
               1 [:peerURLs (cis->repeated cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->MemberAddRequest)))

(defn ecis->MemberAddRequest
  "Embedded CodedInputStream to MemberAddRequest"
  [is]
  (cis->embedded cis->MemberAddRequest is))

(defn new-MemberAddRequest
  "Creates a new instance from a map, similar to map->MemberAddRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::MemberAddRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::MemberAddRequest-spec init))))]}
  (-> (merge MemberAddRequest-defaults init)
      (map->MemberAddRequest)))

(defn pb->MemberAddRequest
  "Protobuf to MemberAddRequest"
  [input]
  (cis->MemberAddRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; HashKVResponse
;-----------------------------------------------------------------------------
(defrecord HashKVResponse [header hash compact-revision]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)
    (write-UInt32 2  {:optimize true} (:hash this) os)
    (write-Int64 3  {:optimize true} (:compact-revision this) os)))

(s/def :etcdserverpb.messages.HashKVResponse/hash int?)
(s/def :etcdserverpb.messages.HashKVResponse/compact-revision int?)
(s/def ::HashKVResponse-spec (s/keys :opt-un [:etcdserverpb.messages.HashKVResponse/hash :etcdserverpb.messages.HashKVResponse/compact-revision ]))
(def HashKVResponse-defaults {:hash 0 :compact-revision 0 })

(defn cis->HashKVResponse
  "CodedInputStream to HashKVResponse"
  [is]
  (->> (tag-map HashKVResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]
               2 [:hash (cis->UInt32 is)]
               3 [:compact-revision (cis->Int64 is)]

               [index (cis->undefined tag is)]))
         is)
        (map->HashKVResponse)))

(defn ecis->HashKVResponse
  "Embedded CodedInputStream to HashKVResponse"
  [is]
  (cis->embedded cis->HashKVResponse is))

(defn new-HashKVResponse
  "Creates a new instance from a map, similar to map->HashKVResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::HashKVResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::HashKVResponse-spec init))))]}
  (-> (merge HashKVResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (map->HashKVResponse)))

(defn pb->HashKVResponse
  "Protobuf to HashKVResponse"
  [input]
  (cis->HashKVResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthUserDeleteRequest
;-----------------------------------------------------------------------------
(defrecord AuthUserDeleteRequest [name]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:name this) os)))

(s/def :etcdserverpb.messages.AuthUserDeleteRequest/name string?)
(s/def ::AuthUserDeleteRequest-spec (s/keys :opt-un [:etcdserverpb.messages.AuthUserDeleteRequest/name ]))
(def AuthUserDeleteRequest-defaults {:name "" })

(defn cis->AuthUserDeleteRequest
  "CodedInputStream to AuthUserDeleteRequest"
  [is]
  (->> (tag-map AuthUserDeleteRequest-defaults
         (fn [tag index]
             (case index
               1 [:name (cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthUserDeleteRequest)))

(defn ecis->AuthUserDeleteRequest
  "Embedded CodedInputStream to AuthUserDeleteRequest"
  [is]
  (cis->embedded cis->AuthUserDeleteRequest is))

(defn new-AuthUserDeleteRequest
  "Creates a new instance from a map, similar to map->AuthUserDeleteRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthUserDeleteRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthUserDeleteRequest-spec init))))]}
  (-> (merge AuthUserDeleteRequest-defaults init)
      (map->AuthUserDeleteRequest)))

(defn pb->AuthUserDeleteRequest
  "Protobuf to AuthUserDeleteRequest"
  [input]
  (cis->AuthUserDeleteRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AlarmRequest
;-----------------------------------------------------------------------------
(defrecord AlarmRequest [action memberID alarm]
  pb/Writer

  (serialize [this os]
    (write-AlarmRequest-AlarmAction 1  {:optimize true} (:action this) os)
    (write-UInt64 2  {:optimize true} (:memberID this) os)
    (write-AlarmType 3  {:optimize true} (:alarm this) os)))

(s/def :etcdserverpb.messages.AlarmRequest/action (s/or :keyword keyword? :int int?))
(s/def :etcdserverpb.messages.AlarmRequest/memberID int?)
(s/def :etcdserverpb.messages.AlarmRequest/alarm (s/or :keyword keyword? :int int?))
(s/def ::AlarmRequest-spec (s/keys :opt-un [:etcdserverpb.messages.AlarmRequest/action :etcdserverpb.messages.AlarmRequest/memberID :etcdserverpb.messages.AlarmRequest/alarm ]))
(def AlarmRequest-defaults {:action (AlarmRequest-AlarmAction-val2label 0) :memberID 0 :alarm (AlarmType-val2label 0) })

(defn cis->AlarmRequest
  "CodedInputStream to AlarmRequest"
  [is]
  (->> (tag-map AlarmRequest-defaults
         (fn [tag index]
             (case index
               1 [:action (cis->AlarmRequest-AlarmAction is)]
               2 [:memberID (cis->UInt64 is)]
               3 [:alarm (cis->AlarmType is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AlarmRequest)))

(defn ecis->AlarmRequest
  "Embedded CodedInputStream to AlarmRequest"
  [is]
  (cis->embedded cis->AlarmRequest is))

(defn new-AlarmRequest
  "Creates a new instance from a map, similar to map->AlarmRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AlarmRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AlarmRequest-spec init))))]}
  (-> (merge AlarmRequest-defaults init)
      (map->AlarmRequest)))

(defn pb->AlarmRequest
  "Protobuf to AlarmRequest"
  [input]
  (cis->AlarmRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; MoveLeaderResponse
;-----------------------------------------------------------------------------
(defrecord MoveLeaderResponse [header]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)))

(s/def ::MoveLeaderResponse-spec (s/keys :opt-un []))
(def MoveLeaderResponse-defaults {})

(defn cis->MoveLeaderResponse
  "CodedInputStream to MoveLeaderResponse"
  [is]
  (->> (tag-map MoveLeaderResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]

               [index (cis->undefined tag is)]))
         is)
        (map->MoveLeaderResponse)))

(defn ecis->MoveLeaderResponse
  "Embedded CodedInputStream to MoveLeaderResponse"
  [is]
  (cis->embedded cis->MoveLeaderResponse is))

(defn new-MoveLeaderResponse
  "Creates a new instance from a map, similar to map->MoveLeaderResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::MoveLeaderResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::MoveLeaderResponse-spec init))))]}
  (-> (merge MoveLeaderResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (map->MoveLeaderResponse)))

(defn pb->MoveLeaderResponse
  "Protobuf to MoveLeaderResponse"
  [input]
  (cis->MoveLeaderResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; DeleteRangeResponse
;-----------------------------------------------------------------------------
(defrecord DeleteRangeResponse [header deleted prev-kvs]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)
    (write-Int64 2  {:optimize true} (:deleted this) os)
    (write-repeated write-embedded 3 (:prev-kvs this) os)))

(s/def :etcdserverpb.messages.DeleteRangeResponse/deleted int?)

(s/def ::DeleteRangeResponse-spec (s/keys :opt-un [:etcdserverpb.messages.DeleteRangeResponse/deleted ]))
(def DeleteRangeResponse-defaults {:deleted 0 :prev-kvs [] })

(defn cis->DeleteRangeResponse
  "CodedInputStream to DeleteRangeResponse"
  [is]
  (->> (tag-map DeleteRangeResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]
               2 [:deleted (cis->Int64 is)]
               3 [:prev-kvs (cis->repeated mvccpb/ecis->KeyValue is)]

               [index (cis->undefined tag is)]))
         is)
        (map->DeleteRangeResponse)))

(defn ecis->DeleteRangeResponse
  "Embedded CodedInputStream to DeleteRangeResponse"
  [is]
  (cis->embedded cis->DeleteRangeResponse is))

(defn new-DeleteRangeResponse
  "Creates a new instance from a map, similar to map->DeleteRangeResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::DeleteRangeResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::DeleteRangeResponse-spec init))))]}
  (-> (merge DeleteRangeResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (cond-> (contains? init :prev-kvs) (update :prev-kvs #(map mvccpb/new-KeyValue %)))
      (map->DeleteRangeResponse)))

(defn pb->DeleteRangeResponse
  "Protobuf to DeleteRangeResponse"
  [input]
  (cis->DeleteRangeResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; WatchRequest
;-----------------------------------------------------------------------------
(defrecord WatchRequest [request-union]
  pb/Writer

  (serialize [this os]
    (write-request-union  (:request-union this) os)))

(s/def ::WatchRequest-spec (s/keys :opt-un []))
(def WatchRequest-defaults {})

(defn cis->WatchRequest
  "CodedInputStream to WatchRequest"
  [is]
  (->> (tag-map WatchRequest-defaults
         (fn [tag index]
             (case index
               1 [:request-union {:create-request (ecis->WatchCreateRequest is)}]
               2 [:request-union {:cancel-request (ecis->WatchCancelRequest is)}]

               [index (cis->undefined tag is)]))
         is)
        (map->WatchRequest)))

(defn ecis->WatchRequest
  "Embedded CodedInputStream to WatchRequest"
  [is]
  (cis->embedded cis->WatchRequest is))

(defn new-WatchRequest
  "Creates a new instance from a map, similar to map->WatchRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::WatchRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::WatchRequest-spec init))))]}
  (-> (merge WatchRequest-defaults init)
      (convert-request-union)
      (map->WatchRequest)))

(defn pb->WatchRequest
  "Protobuf to WatchRequest"
  [input]
  (cis->WatchRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; LeaseGrantRequest
;-----------------------------------------------------------------------------
(defrecord LeaseGrantRequest [TTL ID]
  pb/Writer

  (serialize [this os]
    (write-Int64 1  {:optimize true} (:TTL this) os)
    (write-Int64 2  {:optimize true} (:ID this) os)))

(s/def :etcdserverpb.messages.LeaseGrantRequest/TTL int?)
(s/def :etcdserverpb.messages.LeaseGrantRequest/ID int?)
(s/def ::LeaseGrantRequest-spec (s/keys :opt-un [:etcdserverpb.messages.LeaseGrantRequest/TTL :etcdserverpb.messages.LeaseGrantRequest/ID ]))
(def LeaseGrantRequest-defaults {:TTL 0 :ID 0 })

(defn cis->LeaseGrantRequest
  "CodedInputStream to LeaseGrantRequest"
  [is]
  (->> (tag-map LeaseGrantRequest-defaults
         (fn [tag index]
             (case index
               1 [:TTL (cis->Int64 is)]
               2 [:ID (cis->Int64 is)]

               [index (cis->undefined tag is)]))
         is)
        (map->LeaseGrantRequest)))

(defn ecis->LeaseGrantRequest
  "Embedded CodedInputStream to LeaseGrantRequest"
  [is]
  (cis->embedded cis->LeaseGrantRequest is))

(defn new-LeaseGrantRequest
  "Creates a new instance from a map, similar to map->LeaseGrantRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::LeaseGrantRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::LeaseGrantRequest-spec init))))]}
  (-> (merge LeaseGrantRequest-defaults init)
      (map->LeaseGrantRequest)))

(defn pb->LeaseGrantRequest
  "Protobuf to LeaseGrantRequest"
  [input]
  (cis->LeaseGrantRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; LeaseGrantResponse
;-----------------------------------------------------------------------------
(defrecord LeaseGrantResponse [header ID TTL error]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)
    (write-Int64 2  {:optimize true} (:ID this) os)
    (write-Int64 3  {:optimize true} (:TTL this) os)
    (write-String 4  {:optimize true} (:error this) os)))

(s/def :etcdserverpb.messages.LeaseGrantResponse/ID int?)
(s/def :etcdserverpb.messages.LeaseGrantResponse/TTL int?)
(s/def :etcdserverpb.messages.LeaseGrantResponse/error string?)
(s/def ::LeaseGrantResponse-spec (s/keys :opt-un [:etcdserverpb.messages.LeaseGrantResponse/ID :etcdserverpb.messages.LeaseGrantResponse/TTL :etcdserverpb.messages.LeaseGrantResponse/error ]))
(def LeaseGrantResponse-defaults {:ID 0 :TTL 0 :error "" })

(defn cis->LeaseGrantResponse
  "CodedInputStream to LeaseGrantResponse"
  [is]
  (->> (tag-map LeaseGrantResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]
               2 [:ID (cis->Int64 is)]
               3 [:TTL (cis->Int64 is)]
               4 [:error (cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->LeaseGrantResponse)))

(defn ecis->LeaseGrantResponse
  "Embedded CodedInputStream to LeaseGrantResponse"
  [is]
  (cis->embedded cis->LeaseGrantResponse is))

(defn new-LeaseGrantResponse
  "Creates a new instance from a map, similar to map->LeaseGrantResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::LeaseGrantResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::LeaseGrantResponse-spec init))))]}
  (-> (merge LeaseGrantResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (map->LeaseGrantResponse)))

(defn pb->LeaseGrantResponse
  "Protobuf to LeaseGrantResponse"
  [input]
  (cis->LeaseGrantResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; MemberUpdateRequest
;-----------------------------------------------------------------------------
(defrecord MemberUpdateRequest [ID peerURLs]
  pb/Writer

  (serialize [this os]
    (write-UInt64 1  {:optimize true} (:ID this) os)
    (write-repeated write-String 2 (:peerURLs this) os)))

(s/def :etcdserverpb.messages.MemberUpdateRequest/ID int?)
(s/def :etcdserverpb.messages.MemberUpdateRequest/peerURLs (s/every string?))
(s/def ::MemberUpdateRequest-spec (s/keys :opt-un [:etcdserverpb.messages.MemberUpdateRequest/ID :etcdserverpb.messages.MemberUpdateRequest/peerURLs ]))
(def MemberUpdateRequest-defaults {:ID 0 :peerURLs [] })

(defn cis->MemberUpdateRequest
  "CodedInputStream to MemberUpdateRequest"
  [is]
  (->> (tag-map MemberUpdateRequest-defaults
         (fn [tag index]
             (case index
               1 [:ID (cis->UInt64 is)]
               2 [:peerURLs (cis->repeated cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->MemberUpdateRequest)))

(defn ecis->MemberUpdateRequest
  "Embedded CodedInputStream to MemberUpdateRequest"
  [is]
  (cis->embedded cis->MemberUpdateRequest is))

(defn new-MemberUpdateRequest
  "Creates a new instance from a map, similar to map->MemberUpdateRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::MemberUpdateRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::MemberUpdateRequest-spec init))))]}
  (-> (merge MemberUpdateRequest-defaults init)
      (map->MemberUpdateRequest)))

(defn pb->MemberUpdateRequest
  "Protobuf to MemberUpdateRequest"
  [input]
  (cis->MemberUpdateRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthUserChangePasswordRequest
;-----------------------------------------------------------------------------
(defrecord AuthUserChangePasswordRequest [name password]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:name this) os)
    (write-String 2  {:optimize true} (:password this) os)))

(s/def :etcdserverpb.messages.AuthUserChangePasswordRequest/name string?)
(s/def :etcdserverpb.messages.AuthUserChangePasswordRequest/password string?)
(s/def ::AuthUserChangePasswordRequest-spec (s/keys :opt-un [:etcdserverpb.messages.AuthUserChangePasswordRequest/name :etcdserverpb.messages.AuthUserChangePasswordRequest/password ]))
(def AuthUserChangePasswordRequest-defaults {:name "" :password "" })

(defn cis->AuthUserChangePasswordRequest
  "CodedInputStream to AuthUserChangePasswordRequest"
  [is]
  (->> (tag-map AuthUserChangePasswordRequest-defaults
         (fn [tag index]
             (case index
               1 [:name (cis->String is)]
               2 [:password (cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthUserChangePasswordRequest)))

(defn ecis->AuthUserChangePasswordRequest
  "Embedded CodedInputStream to AuthUserChangePasswordRequest"
  [is]
  (cis->embedded cis->AuthUserChangePasswordRequest is))

(defn new-AuthUserChangePasswordRequest
  "Creates a new instance from a map, similar to map->AuthUserChangePasswordRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthUserChangePasswordRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthUserChangePasswordRequest-spec init))))]}
  (-> (merge AuthUserChangePasswordRequest-defaults init)
      (map->AuthUserChangePasswordRequest)))

(defn pb->AuthUserChangePasswordRequest
  "Protobuf to AuthUserChangePasswordRequest"
  [input]
  (cis->AuthUserChangePasswordRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthRoleDeleteResponse
;-----------------------------------------------------------------------------
(defrecord AuthRoleDeleteResponse [header]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)))

(s/def ::AuthRoleDeleteResponse-spec (s/keys :opt-un []))
(def AuthRoleDeleteResponse-defaults {})

(defn cis->AuthRoleDeleteResponse
  "CodedInputStream to AuthRoleDeleteResponse"
  [is]
  (->> (tag-map AuthRoleDeleteResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthRoleDeleteResponse)))

(defn ecis->AuthRoleDeleteResponse
  "Embedded CodedInputStream to AuthRoleDeleteResponse"
  [is]
  (cis->embedded cis->AuthRoleDeleteResponse is))

(defn new-AuthRoleDeleteResponse
  "Creates a new instance from a map, similar to map->AuthRoleDeleteResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthRoleDeleteResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthRoleDeleteResponse-spec init))))]}
  (-> (merge AuthRoleDeleteResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (map->AuthRoleDeleteResponse)))

(defn pb->AuthRoleDeleteResponse
  "Protobuf to AuthRoleDeleteResponse"
  [input]
  (cis->AuthRoleDeleteResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthenticateRequest
;-----------------------------------------------------------------------------
(defrecord AuthenticateRequest [name password]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:name this) os)
    (write-String 2  {:optimize true} (:password this) os)))

(s/def :etcdserverpb.messages.AuthenticateRequest/name string?)
(s/def :etcdserverpb.messages.AuthenticateRequest/password string?)
(s/def ::AuthenticateRequest-spec (s/keys :opt-un [:etcdserverpb.messages.AuthenticateRequest/name :etcdserverpb.messages.AuthenticateRequest/password ]))
(def AuthenticateRequest-defaults {:name "" :password "" })

(defn cis->AuthenticateRequest
  "CodedInputStream to AuthenticateRequest"
  [is]
  (->> (tag-map AuthenticateRequest-defaults
         (fn [tag index]
             (case index
               1 [:name (cis->String is)]
               2 [:password (cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthenticateRequest)))

(defn ecis->AuthenticateRequest
  "Embedded CodedInputStream to AuthenticateRequest"
  [is]
  (cis->embedded cis->AuthenticateRequest is))

(defn new-AuthenticateRequest
  "Creates a new instance from a map, similar to map->AuthenticateRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthenticateRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthenticateRequest-spec init))))]}
  (-> (merge AuthenticateRequest-defaults init)
      (map->AuthenticateRequest)))

(defn pb->AuthenticateRequest
  "Protobuf to AuthenticateRequest"
  [input]
  (cis->AuthenticateRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; Member
;-----------------------------------------------------------------------------
(defrecord Member [ID name peerURLs clientURLs]
  pb/Writer

  (serialize [this os]
    (write-UInt64 1  {:optimize true} (:ID this) os)
    (write-String 2  {:optimize true} (:name this) os)
    (write-repeated write-String 3 (:peerURLs this) os)
    (write-repeated write-String 4 (:clientURLs this) os)))

(s/def :etcdserverpb.messages.Member/ID int?)
(s/def :etcdserverpb.messages.Member/name string?)
(s/def :etcdserverpb.messages.Member/peerURLs (s/every string?))
(s/def :etcdserverpb.messages.Member/clientURLs (s/every string?))
(s/def ::Member-spec (s/keys :opt-un [:etcdserverpb.messages.Member/ID :etcdserverpb.messages.Member/name :etcdserverpb.messages.Member/peerURLs :etcdserverpb.messages.Member/clientURLs ]))
(def Member-defaults {:ID 0 :name "" :peerURLs [] :clientURLs [] })

(defn cis->Member
  "CodedInputStream to Member"
  [is]
  (->> (tag-map Member-defaults
         (fn [tag index]
             (case index
               1 [:ID (cis->UInt64 is)]
               2 [:name (cis->String is)]
               3 [:peerURLs (cis->repeated cis->String is)]
               4 [:clientURLs (cis->repeated cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->Member)))

(defn ecis->Member
  "Embedded CodedInputStream to Member"
  [is]
  (cis->embedded cis->Member is))

(defn new-Member
  "Creates a new instance from a map, similar to map->Member except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Member-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Member-spec init))))]}
  (-> (merge Member-defaults init)
      (map->Member)))

(defn pb->Member
  "Protobuf to Member"
  [input]
  (cis->Member (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthUserGetRequest
;-----------------------------------------------------------------------------
(defrecord AuthUserGetRequest [name]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:name this) os)))

(s/def :etcdserverpb.messages.AuthUserGetRequest/name string?)
(s/def ::AuthUserGetRequest-spec (s/keys :opt-un [:etcdserverpb.messages.AuthUserGetRequest/name ]))
(def AuthUserGetRequest-defaults {:name "" })

(defn cis->AuthUserGetRequest
  "CodedInputStream to AuthUserGetRequest"
  [is]
  (->> (tag-map AuthUserGetRequest-defaults
         (fn [tag index]
             (case index
               1 [:name (cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthUserGetRequest)))

(defn ecis->AuthUserGetRequest
  "Embedded CodedInputStream to AuthUserGetRequest"
  [is]
  (cis->embedded cis->AuthUserGetRequest is))

(defn new-AuthUserGetRequest
  "Creates a new instance from a map, similar to map->AuthUserGetRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthUserGetRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthUserGetRequest-spec init))))]}
  (-> (merge AuthUserGetRequest-defaults init)
      (map->AuthUserGetRequest)))

(defn pb->AuthUserGetRequest
  "Protobuf to AuthUserGetRequest"
  [input]
  (cis->AuthUserGetRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AlarmMember
;-----------------------------------------------------------------------------
(defrecord AlarmMember [memberID alarm]
  pb/Writer

  (serialize [this os]
    (write-UInt64 1  {:optimize true} (:memberID this) os)
    (write-AlarmType 2  {:optimize true} (:alarm this) os)))

(s/def :etcdserverpb.messages.AlarmMember/memberID int?)
(s/def :etcdserverpb.messages.AlarmMember/alarm (s/or :keyword keyword? :int int?))
(s/def ::AlarmMember-spec (s/keys :opt-un [:etcdserverpb.messages.AlarmMember/memberID :etcdserverpb.messages.AlarmMember/alarm ]))
(def AlarmMember-defaults {:memberID 0 :alarm (AlarmType-val2label 0) })

(defn cis->AlarmMember
  "CodedInputStream to AlarmMember"
  [is]
  (->> (tag-map AlarmMember-defaults
         (fn [tag index]
             (case index
               1 [:memberID (cis->UInt64 is)]
               2 [:alarm (cis->AlarmType is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AlarmMember)))

(defn ecis->AlarmMember
  "Embedded CodedInputStream to AlarmMember"
  [is]
  (cis->embedded cis->AlarmMember is))

(defn new-AlarmMember
  "Creates a new instance from a map, similar to map->AlarmMember except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AlarmMember-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AlarmMember-spec init))))]}
  (-> (merge AlarmMember-defaults init)
      (map->AlarmMember)))

(defn pb->AlarmMember
  "Protobuf to AlarmMember"
  [input]
  (cis->AlarmMember (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthRoleDeleteRequest
;-----------------------------------------------------------------------------
(defrecord AuthRoleDeleteRequest [role]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:role this) os)))

(s/def :etcdserverpb.messages.AuthRoleDeleteRequest/role string?)
(s/def ::AuthRoleDeleteRequest-spec (s/keys :opt-un [:etcdserverpb.messages.AuthRoleDeleteRequest/role ]))
(def AuthRoleDeleteRequest-defaults {:role "" })

(defn cis->AuthRoleDeleteRequest
  "CodedInputStream to AuthRoleDeleteRequest"
  [is]
  (->> (tag-map AuthRoleDeleteRequest-defaults
         (fn [tag index]
             (case index
               1 [:role (cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthRoleDeleteRequest)))

(defn ecis->AuthRoleDeleteRequest
  "Embedded CodedInputStream to AuthRoleDeleteRequest"
  [is]
  (cis->embedded cis->AuthRoleDeleteRequest is))

(defn new-AuthRoleDeleteRequest
  "Creates a new instance from a map, similar to map->AuthRoleDeleteRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthRoleDeleteRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthRoleDeleteRequest-spec init))))]}
  (-> (merge AuthRoleDeleteRequest-defaults init)
      (map->AuthRoleDeleteRequest)))

(defn pb->AuthRoleDeleteRequest
  "Protobuf to AuthRoleDeleteRequest"
  [input]
  (cis->AuthRoleDeleteRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthRoleListResponse
;-----------------------------------------------------------------------------
(defrecord AuthRoleListResponse [header roles]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)
    (write-repeated write-String 2 (:roles this) os)))

(s/def :etcdserverpb.messages.AuthRoleListResponse/roles (s/every string?))
(s/def ::AuthRoleListResponse-spec (s/keys :opt-un [:etcdserverpb.messages.AuthRoleListResponse/roles ]))
(def AuthRoleListResponse-defaults {:roles [] })

(defn cis->AuthRoleListResponse
  "CodedInputStream to AuthRoleListResponse"
  [is]
  (->> (tag-map AuthRoleListResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]
               2 [:roles (cis->repeated cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthRoleListResponse)))

(defn ecis->AuthRoleListResponse
  "Embedded CodedInputStream to AuthRoleListResponse"
  [is]
  (cis->embedded cis->AuthRoleListResponse is))

(defn new-AuthRoleListResponse
  "Creates a new instance from a map, similar to map->AuthRoleListResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthRoleListResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthRoleListResponse-spec init))))]}
  (-> (merge AuthRoleListResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (map->AuthRoleListResponse)))

(defn pb->AuthRoleListResponse
  "Protobuf to AuthRoleListResponse"
  [input]
  (cis->AuthRoleListResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; CompactionResponse
;-----------------------------------------------------------------------------
(defrecord CompactionResponse [header]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)))

(s/def ::CompactionResponse-spec (s/keys :opt-un []))
(def CompactionResponse-defaults {})

(defn cis->CompactionResponse
  "CodedInputStream to CompactionResponse"
  [is]
  (->> (tag-map CompactionResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]

               [index (cis->undefined tag is)]))
         is)
        (map->CompactionResponse)))

(defn ecis->CompactionResponse
  "Embedded CodedInputStream to CompactionResponse"
  [is]
  (cis->embedded cis->CompactionResponse is))

(defn new-CompactionResponse
  "Creates a new instance from a map, similar to map->CompactionResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::CompactionResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::CompactionResponse-spec init))))]}
  (-> (merge CompactionResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (map->CompactionResponse)))

(defn pb->CompactionResponse
  "Protobuf to CompactionResponse"
  [input]
  (cis->CompactionResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; WatchCreateRequest
;-----------------------------------------------------------------------------
(defrecord WatchCreateRequest [key range-end start-revision progress-notify filters prev-kv]
  pb/Writer

  (serialize [this os]
    (write-Bytes 1  {:optimize true} (:key this) os)
    (write-Bytes 2  {:optimize true} (:range-end this) os)
    (write-Int64 3  {:optimize true} (:start-revision this) os)
    (write-Bool 4  {:optimize true} (:progress-notify this) os)
    (write-repeated write-WatchCreateRequest-FilterType 5 (:filters this) os)
    (write-Bool 6  {:optimize true} (:prev-kv this) os)))

(s/def :etcdserverpb.messages.WatchCreateRequest/key bytes?)
(s/def :etcdserverpb.messages.WatchCreateRequest/range-end bytes?)
(s/def :etcdserverpb.messages.WatchCreateRequest/start-revision int?)
(s/def :etcdserverpb.messages.WatchCreateRequest/progress-notify boolean?)
(s/def :etcdserverpb.messages.WatchCreateRequest/filters (s/every (s/or :keyword keyword? :int int?)))
(s/def :etcdserverpb.messages.WatchCreateRequest/prev-kv boolean?)
(s/def ::WatchCreateRequest-spec (s/keys :opt-un [:etcdserverpb.messages.WatchCreateRequest/key :etcdserverpb.messages.WatchCreateRequest/range-end :etcdserverpb.messages.WatchCreateRequest/start-revision :etcdserverpb.messages.WatchCreateRequest/progress-notify :etcdserverpb.messages.WatchCreateRequest/filters :etcdserverpb.messages.WatchCreateRequest/prev-kv ]))
(def WatchCreateRequest-defaults {:key (byte-array 0) :range-end (byte-array 0) :start-revision 0 :progress-notify false :filters [] :prev-kv false })

(defn cis->WatchCreateRequest
  "CodedInputStream to WatchCreateRequest"
  [is]
  (->> (tag-map WatchCreateRequest-defaults
         (fn [tag index]
             (case index
               1 [:key (cis->Bytes is)]
               2 [:range-end (cis->Bytes is)]
               3 [:start-revision (cis->Int64 is)]
               4 [:progress-notify (cis->Bool is)]
               5 [:filters (cis->packablerepeated tag cis->WatchCreateRequest-FilterType is)]
               6 [:prev-kv (cis->Bool is)]

               [index (cis->undefined tag is)]))
         is)
        (map->WatchCreateRequest)))

(defn ecis->WatchCreateRequest
  "Embedded CodedInputStream to WatchCreateRequest"
  [is]
  (cis->embedded cis->WatchCreateRequest is))

(defn new-WatchCreateRequest
  "Creates a new instance from a map, similar to map->WatchCreateRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::WatchCreateRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::WatchCreateRequest-spec init))))]}
  (-> (merge WatchCreateRequest-defaults init)
      (map->WatchCreateRequest)))

(defn pb->WatchCreateRequest
  "Protobuf to WatchCreateRequest"
  [input]
  (cis->WatchCreateRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthUserGrantRoleResponse
;-----------------------------------------------------------------------------
(defrecord AuthUserGrantRoleResponse [header]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)))

(s/def ::AuthUserGrantRoleResponse-spec (s/keys :opt-un []))
(def AuthUserGrantRoleResponse-defaults {})

(defn cis->AuthUserGrantRoleResponse
  "CodedInputStream to AuthUserGrantRoleResponse"
  [is]
  (->> (tag-map AuthUserGrantRoleResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthUserGrantRoleResponse)))

(defn ecis->AuthUserGrantRoleResponse
  "Embedded CodedInputStream to AuthUserGrantRoleResponse"
  [is]
  (cis->embedded cis->AuthUserGrantRoleResponse is))

(defn new-AuthUserGrantRoleResponse
  "Creates a new instance from a map, similar to map->AuthUserGrantRoleResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthUserGrantRoleResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthUserGrantRoleResponse-spec init))))]}
  (-> (merge AuthUserGrantRoleResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (map->AuthUserGrantRoleResponse)))

(defn pb->AuthUserGrantRoleResponse
  "Protobuf to AuthUserGrantRoleResponse"
  [input]
  (cis->AuthUserGrantRoleResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthRoleGrantPermissionRequest
;-----------------------------------------------------------------------------
(defrecord AuthRoleGrantPermissionRequest [name perm]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:name this) os)
    (write-embedded 2 (:perm this) os)))

(s/def :etcdserverpb.messages.AuthRoleGrantPermissionRequest/name string?)

(s/def ::AuthRoleGrantPermissionRequest-spec (s/keys :opt-un [:etcdserverpb.messages.AuthRoleGrantPermissionRequest/name ]))
(def AuthRoleGrantPermissionRequest-defaults {:name "" })

(defn cis->AuthRoleGrantPermissionRequest
  "CodedInputStream to AuthRoleGrantPermissionRequest"
  [is]
  (->> (tag-map AuthRoleGrantPermissionRequest-defaults
         (fn [tag index]
             (case index
               1 [:name (cis->String is)]
               2 [:perm (authpb/ecis->Permission is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthRoleGrantPermissionRequest)))

(defn ecis->AuthRoleGrantPermissionRequest
  "Embedded CodedInputStream to AuthRoleGrantPermissionRequest"
  [is]
  (cis->embedded cis->AuthRoleGrantPermissionRequest is))

(defn new-AuthRoleGrantPermissionRequest
  "Creates a new instance from a map, similar to map->AuthRoleGrantPermissionRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthRoleGrantPermissionRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthRoleGrantPermissionRequest-spec init))))]}
  (-> (merge AuthRoleGrantPermissionRequest-defaults init)
      (cond-> (contains? init :perm) (update :perm authpb/new-Permission))
      (map->AuthRoleGrantPermissionRequest)))

(defn pb->AuthRoleGrantPermissionRequest
  "Protobuf to AuthRoleGrantPermissionRequest"
  [input]
  (cis->AuthRoleGrantPermissionRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; RangeResponse
;-----------------------------------------------------------------------------
(defrecord RangeResponse [header kvs more count]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)
    (write-repeated write-embedded 2 (:kvs this) os)
    (write-Bool 3  {:optimize true} (:more this) os)
    (write-Int64 4  {:optimize true} (:count this) os)))

(s/def :etcdserverpb.messages.RangeResponse/more boolean?)
(s/def :etcdserverpb.messages.RangeResponse/count int?)
(s/def ::RangeResponse-spec (s/keys :opt-un [:etcdserverpb.messages.RangeResponse/more :etcdserverpb.messages.RangeResponse/count ]))
(def RangeResponse-defaults {:kvs [] :more false :count 0 })

(defn cis->RangeResponse
  "CodedInputStream to RangeResponse"
  [is]
  (->> (tag-map RangeResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]
               2 [:kvs (cis->repeated mvccpb/ecis->KeyValue is)]
               3 [:more (cis->Bool is)]
               4 [:count (cis->Int64 is)]

               [index (cis->undefined tag is)]))
         is)
        (map->RangeResponse)))

(defn ecis->RangeResponse
  "Embedded CodedInputStream to RangeResponse"
  [is]
  (cis->embedded cis->RangeResponse is))

(defn new-RangeResponse
  "Creates a new instance from a map, similar to map->RangeResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::RangeResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::RangeResponse-spec init))))]}
  (-> (merge RangeResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (cond-> (contains? init :kvs) (update :kvs #(map mvccpb/new-KeyValue %)))
      (map->RangeResponse)))

(defn pb->RangeResponse
  "Protobuf to RangeResponse"
  [input]
  (cis->RangeResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; PutResponse
;-----------------------------------------------------------------------------
(defrecord PutResponse [header prev-kv]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)
    (write-embedded 2 (:prev-kv this) os)))

(s/def ::PutResponse-spec (s/keys :opt-un []))
(def PutResponse-defaults {})

(defn cis->PutResponse
  "CodedInputStream to PutResponse"
  [is]
  (->> (tag-map PutResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]
               2 [:prev-kv (mvccpb/ecis->KeyValue is)]

               [index (cis->undefined tag is)]))
         is)
        (map->PutResponse)))

(defn ecis->PutResponse
  "Embedded CodedInputStream to PutResponse"
  [is]
  (cis->embedded cis->PutResponse is))

(defn new-PutResponse
  "Creates a new instance from a map, similar to map->PutResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::PutResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::PutResponse-spec init))))]}
  (-> (merge PutResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (cond-> (contains? init :prev-kv) (update :prev-kv mvccpb/new-KeyValue))
      (map->PutResponse)))

(defn pb->PutResponse
  "Protobuf to PutResponse"
  [input]
  (cis->PutResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; MemberRemoveResponse
;-----------------------------------------------------------------------------
(defrecord MemberRemoveResponse [header members]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)
    (write-repeated write-embedded 2 (:members this) os)))

(s/def ::MemberRemoveResponse-spec (s/keys :opt-un []))
(def MemberRemoveResponse-defaults {:members [] })

(defn cis->MemberRemoveResponse
  "CodedInputStream to MemberRemoveResponse"
  [is]
  (->> (tag-map MemberRemoveResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]
               2 [:members (cis->repeated ecis->Member is)]

               [index (cis->undefined tag is)]))
         is)
        (map->MemberRemoveResponse)))

(defn ecis->MemberRemoveResponse
  "Embedded CodedInputStream to MemberRemoveResponse"
  [is]
  (cis->embedded cis->MemberRemoveResponse is))

(defn new-MemberRemoveResponse
  "Creates a new instance from a map, similar to map->MemberRemoveResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::MemberRemoveResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::MemberRemoveResponse-spec init))))]}
  (-> (merge MemberRemoveResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (cond-> (contains? init :members) (update :members #(map new-Member %)))
      (map->MemberRemoveResponse)))

(defn pb->MemberRemoveResponse
  "Protobuf to MemberRemoveResponse"
  [input]
  (cis->MemberRemoveResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; LeaseTimeToLiveRequest
;-----------------------------------------------------------------------------
(defrecord LeaseTimeToLiveRequest [ID keys]
  pb/Writer

  (serialize [this os]
    (write-Int64 1  {:optimize true} (:ID this) os)
    (write-Bool 2  {:optimize true} (:keys this) os)))

(s/def :etcdserverpb.messages.LeaseTimeToLiveRequest/ID int?)
(s/def :etcdserverpb.messages.LeaseTimeToLiveRequest/keys boolean?)
(s/def ::LeaseTimeToLiveRequest-spec (s/keys :opt-un [:etcdserverpb.messages.LeaseTimeToLiveRequest/ID :etcdserverpb.messages.LeaseTimeToLiveRequest/keys ]))
(def LeaseTimeToLiveRequest-defaults {:ID 0 :keys false })

(defn cis->LeaseTimeToLiveRequest
  "CodedInputStream to LeaseTimeToLiveRequest"
  [is]
  (->> (tag-map LeaseTimeToLiveRequest-defaults
         (fn [tag index]
             (case index
               1 [:ID (cis->Int64 is)]
               2 [:keys (cis->Bool is)]

               [index (cis->undefined tag is)]))
         is)
        (map->LeaseTimeToLiveRequest)))

(defn ecis->LeaseTimeToLiveRequest
  "Embedded CodedInputStream to LeaseTimeToLiveRequest"
  [is]
  (cis->embedded cis->LeaseTimeToLiveRequest is))

(defn new-LeaseTimeToLiveRequest
  "Creates a new instance from a map, similar to map->LeaseTimeToLiveRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::LeaseTimeToLiveRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::LeaseTimeToLiveRequest-spec init))))]}
  (-> (merge LeaseTimeToLiveRequest-defaults init)
      (map->LeaseTimeToLiveRequest)))

(defn pb->LeaseTimeToLiveRequest
  "Protobuf to LeaseTimeToLiveRequest"
  [input]
  (cis->LeaseTimeToLiveRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; DefragmentRequest
;-----------------------------------------------------------------------------
(defrecord DefragmentRequest []
  pb/Writer

  (serialize [this os]
))

(s/def ::DefragmentRequest-spec (s/keys :opt-un []))
(def DefragmentRequest-defaults {})

(defn cis->DefragmentRequest
  "CodedInputStream to DefragmentRequest"
  [is]
  (->> (tag-map DefragmentRequest-defaults
         (fn [tag index]
             (case index
               [index (cis->undefined tag is)]))
         is)
        (map->DefragmentRequest)))

(defn ecis->DefragmentRequest
  "Embedded CodedInputStream to DefragmentRequest"
  [is]
  (cis->embedded cis->DefragmentRequest is))

(defn new-DefragmentRequest
  "Creates a new instance from a map, similar to map->DefragmentRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::DefragmentRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::DefragmentRequest-spec init))))]}
  (-> (merge DefragmentRequest-defaults init)
      (map->DefragmentRequest)))

(defn pb->DefragmentRequest
  "Protobuf to DefragmentRequest"
  [input]
  (cis->DefragmentRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthUserRevokeRoleResponse
;-----------------------------------------------------------------------------
(defrecord AuthUserRevokeRoleResponse [header]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)))

(s/def ::AuthUserRevokeRoleResponse-spec (s/keys :opt-un []))
(def AuthUserRevokeRoleResponse-defaults {})

(defn cis->AuthUserRevokeRoleResponse
  "CodedInputStream to AuthUserRevokeRoleResponse"
  [is]
  (->> (tag-map AuthUserRevokeRoleResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthUserRevokeRoleResponse)))

(defn ecis->AuthUserRevokeRoleResponse
  "Embedded CodedInputStream to AuthUserRevokeRoleResponse"
  [is]
  (cis->embedded cis->AuthUserRevokeRoleResponse is))

(defn new-AuthUserRevokeRoleResponse
  "Creates a new instance from a map, similar to map->AuthUserRevokeRoleResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthUserRevokeRoleResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthUserRevokeRoleResponse-spec init))))]}
  (-> (merge AuthUserRevokeRoleResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (map->AuthUserRevokeRoleResponse)))

(defn pb->AuthUserRevokeRoleResponse
  "Protobuf to AuthUserRevokeRoleResponse"
  [input]
  (cis->AuthUserRevokeRoleResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; DeleteRangeRequest
;-----------------------------------------------------------------------------
(defrecord DeleteRangeRequest [key range-end prev-kv]
  pb/Writer

  (serialize [this os]
    (write-Bytes 1  {:optimize true} (:key this) os)
    (write-Bytes 2  {:optimize true} (:range-end this) os)
    (write-Bool 3  {:optimize true} (:prev-kv this) os)))

(s/def :etcdserverpb.messages.DeleteRangeRequest/key bytes?)
(s/def :etcdserverpb.messages.DeleteRangeRequest/range-end bytes?)
(s/def :etcdserverpb.messages.DeleteRangeRequest/prev-kv boolean?)
(s/def ::DeleteRangeRequest-spec (s/keys :opt-un [:etcdserverpb.messages.DeleteRangeRequest/key :etcdserverpb.messages.DeleteRangeRequest/range-end :etcdserverpb.messages.DeleteRangeRequest/prev-kv ]))
(def DeleteRangeRequest-defaults {:key (byte-array 0) :range-end (byte-array 0) :prev-kv false })

(defn cis->DeleteRangeRequest
  "CodedInputStream to DeleteRangeRequest"
  [is]
  (->> (tag-map DeleteRangeRequest-defaults
         (fn [tag index]
             (case index
               1 [:key (cis->Bytes is)]
               2 [:range-end (cis->Bytes is)]
               3 [:prev-kv (cis->Bool is)]

               [index (cis->undefined tag is)]))
         is)
        (map->DeleteRangeRequest)))

(defn ecis->DeleteRangeRequest
  "Embedded CodedInputStream to DeleteRangeRequest"
  [is]
  (cis->embedded cis->DeleteRangeRequest is))

(defn new-DeleteRangeRequest
  "Creates a new instance from a map, similar to map->DeleteRangeRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::DeleteRangeRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::DeleteRangeRequest-spec init))))]}
  (-> (merge DeleteRangeRequest-defaults init)
      (map->DeleteRangeRequest)))

(defn pb->DeleteRangeRequest
  "Protobuf to DeleteRangeRequest"
  [input]
  (cis->DeleteRangeRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; ResponseHeader
;-----------------------------------------------------------------------------
(defrecord ResponseHeader [cluster-id member-id revision raft-term]
  pb/Writer

  (serialize [this os]
    (write-UInt64 1  {:optimize true} (:cluster-id this) os)
    (write-UInt64 2  {:optimize true} (:member-id this) os)
    (write-Int64 3  {:optimize true} (:revision this) os)
    (write-UInt64 4  {:optimize true} (:raft-term this) os)))

(s/def :etcdserverpb.messages.ResponseHeader/cluster-id int?)
(s/def :etcdserverpb.messages.ResponseHeader/member-id int?)
(s/def :etcdserverpb.messages.ResponseHeader/revision int?)
(s/def :etcdserverpb.messages.ResponseHeader/raft-term int?)
(s/def ::ResponseHeader-spec (s/keys :opt-un [:etcdserverpb.messages.ResponseHeader/cluster-id :etcdserverpb.messages.ResponseHeader/member-id :etcdserverpb.messages.ResponseHeader/revision :etcdserverpb.messages.ResponseHeader/raft-term ]))
(def ResponseHeader-defaults {:cluster-id 0 :member-id 0 :revision 0 :raft-term 0 })

(defn cis->ResponseHeader
  "CodedInputStream to ResponseHeader"
  [is]
  (->> (tag-map ResponseHeader-defaults
         (fn [tag index]
             (case index
               1 [:cluster-id (cis->UInt64 is)]
               2 [:member-id (cis->UInt64 is)]
               3 [:revision (cis->Int64 is)]
               4 [:raft-term (cis->UInt64 is)]

               [index (cis->undefined tag is)]))
         is)
        (map->ResponseHeader)))

(defn ecis->ResponseHeader
  "Embedded CodedInputStream to ResponseHeader"
  [is]
  (cis->embedded cis->ResponseHeader is))

(defn new-ResponseHeader
  "Creates a new instance from a map, similar to map->ResponseHeader except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ResponseHeader-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ResponseHeader-spec init))))]}
  (-> (merge ResponseHeader-defaults init)
      (map->ResponseHeader)))

(defn pb->ResponseHeader
  "Protobuf to ResponseHeader"
  [input]
  (cis->ResponseHeader (stream/new-cis input)))

;-----------------------------------------------------------------------------
; SnapshotRequest
;-----------------------------------------------------------------------------
(defrecord SnapshotRequest []
  pb/Writer

  (serialize [this os]
))

(s/def ::SnapshotRequest-spec (s/keys :opt-un []))
(def SnapshotRequest-defaults {})

(defn cis->SnapshotRequest
  "CodedInputStream to SnapshotRequest"
  [is]
  (->> (tag-map SnapshotRequest-defaults
         (fn [tag index]
             (case index
               [index (cis->undefined tag is)]))
         is)
        (map->SnapshotRequest)))

(defn ecis->SnapshotRequest
  "Embedded CodedInputStream to SnapshotRequest"
  [is]
  (cis->embedded cis->SnapshotRequest is))

(defn new-SnapshotRequest
  "Creates a new instance from a map, similar to map->SnapshotRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::SnapshotRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::SnapshotRequest-spec init))))]}
  (-> (merge SnapshotRequest-defaults init)
      (map->SnapshotRequest)))

(defn pb->SnapshotRequest
  "Protobuf to SnapshotRequest"
  [input]
  (cis->SnapshotRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthUserAddResponse
;-----------------------------------------------------------------------------
(defrecord AuthUserAddResponse [header]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)))

(s/def ::AuthUserAddResponse-spec (s/keys :opt-un []))
(def AuthUserAddResponse-defaults {})

(defn cis->AuthUserAddResponse
  "CodedInputStream to AuthUserAddResponse"
  [is]
  (->> (tag-map AuthUserAddResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthUserAddResponse)))

(defn ecis->AuthUserAddResponse
  "Embedded CodedInputStream to AuthUserAddResponse"
  [is]
  (cis->embedded cis->AuthUserAddResponse is))

(defn new-AuthUserAddResponse
  "Creates a new instance from a map, similar to map->AuthUserAddResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthUserAddResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthUserAddResponse-spec init))))]}
  (-> (merge AuthUserAddResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (map->AuthUserAddResponse)))

(defn pb->AuthUserAddResponse
  "Protobuf to AuthUserAddResponse"
  [input]
  (cis->AuthUserAddResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; RangeRequest
;-----------------------------------------------------------------------------
(defrecord RangeRequest [min-create-revision sort-order range-end serializable key revision sort-target count-only max-mod-revision limit max-create-revision keys-only min-mod-revision]
  pb/Writer

  (serialize [this os]
    (write-Int64 12  {:optimize true} (:min-create-revision this) os)
    (write-RangeRequest-SortOrder 5  {:optimize true} (:sort-order this) os)
    (write-Bytes 2  {:optimize true} (:range-end this) os)
    (write-Bool 7  {:optimize true} (:serializable this) os)
    (write-Bytes 1  {:optimize true} (:key this) os)
    (write-Int64 4  {:optimize true} (:revision this) os)
    (write-RangeRequest-SortTarget 6  {:optimize true} (:sort-target this) os)
    (write-Bool 9  {:optimize true} (:count-only this) os)
    (write-Int64 11  {:optimize true} (:max-mod-revision this) os)
    (write-Int64 3  {:optimize true} (:limit this) os)
    (write-Int64 13  {:optimize true} (:max-create-revision this) os)
    (write-Bool 8  {:optimize true} (:keys-only this) os)
    (write-Int64 10  {:optimize true} (:min-mod-revision this) os)))

(s/def :etcdserverpb.messages.RangeRequest/min-create-revision int?)
(s/def :etcdserverpb.messages.RangeRequest/sort-order (s/or :keyword keyword? :int int?))
(s/def :etcdserverpb.messages.RangeRequest/range-end bytes?)
(s/def :etcdserverpb.messages.RangeRequest/serializable boolean?)
(s/def :etcdserverpb.messages.RangeRequest/key bytes?)
(s/def :etcdserverpb.messages.RangeRequest/revision int?)
(s/def :etcdserverpb.messages.RangeRequest/sort-target (s/or :keyword keyword? :int int?))
(s/def :etcdserverpb.messages.RangeRequest/count-only boolean?)
(s/def :etcdserverpb.messages.RangeRequest/max-mod-revision int?)
(s/def :etcdserverpb.messages.RangeRequest/limit int?)
(s/def :etcdserverpb.messages.RangeRequest/max-create-revision int?)
(s/def :etcdserverpb.messages.RangeRequest/keys-only boolean?)
(s/def :etcdserverpb.messages.RangeRequest/min-mod-revision int?)
(s/def ::RangeRequest-spec (s/keys :opt-un [:etcdserverpb.messages.RangeRequest/min-create-revision :etcdserverpb.messages.RangeRequest/sort-order :etcdserverpb.messages.RangeRequest/range-end :etcdserverpb.messages.RangeRequest/serializable :etcdserverpb.messages.RangeRequest/key :etcdserverpb.messages.RangeRequest/revision :etcdserverpb.messages.RangeRequest/sort-target :etcdserverpb.messages.RangeRequest/count-only :etcdserverpb.messages.RangeRequest/max-mod-revision :etcdserverpb.messages.RangeRequest/limit :etcdserverpb.messages.RangeRequest/max-create-revision :etcdserverpb.messages.RangeRequest/keys-only :etcdserverpb.messages.RangeRequest/min-mod-revision ]))
(def RangeRequest-defaults {:min-create-revision 0 :sort-order (RangeRequest-SortOrder-val2label 0) :range-end (byte-array 0) :serializable false :key (byte-array 0) :revision 0 :sort-target (RangeRequest-SortTarget-val2label 0) :count-only false :max-mod-revision 0 :limit 0 :max-create-revision 0 :keys-only false :min-mod-revision 0 })

(defn cis->RangeRequest
  "CodedInputStream to RangeRequest"
  [is]
  (->> (tag-map RangeRequest-defaults
         (fn [tag index]
             (case index
               12 [:min-create-revision (cis->Int64 is)]
               5 [:sort-order (cis->RangeRequest-SortOrder is)]
               2 [:range-end (cis->Bytes is)]
               7 [:serializable (cis->Bool is)]
               1 [:key (cis->Bytes is)]
               4 [:revision (cis->Int64 is)]
               6 [:sort-target (cis->RangeRequest-SortTarget is)]
               9 [:count-only (cis->Bool is)]
               11 [:max-mod-revision (cis->Int64 is)]
               3 [:limit (cis->Int64 is)]
               13 [:max-create-revision (cis->Int64 is)]
               8 [:keys-only (cis->Bool is)]
               10 [:min-mod-revision (cis->Int64 is)]

               [index (cis->undefined tag is)]))
         is)
        (map->RangeRequest)))

(defn ecis->RangeRequest
  "Embedded CodedInputStream to RangeRequest"
  [is]
  (cis->embedded cis->RangeRequest is))

(defn new-RangeRequest
  "Creates a new instance from a map, similar to map->RangeRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::RangeRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::RangeRequest-spec init))))]}
  (-> (merge RangeRequest-defaults init)
      (map->RangeRequest)))

(defn pb->RangeRequest
  "Protobuf to RangeRequest"
  [input]
  (cis->RangeRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthenticateResponse
;-----------------------------------------------------------------------------
(defrecord AuthenticateResponse [header token]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)
    (write-String 2  {:optimize true} (:token this) os)))

(s/def :etcdserverpb.messages.AuthenticateResponse/token string?)
(s/def ::AuthenticateResponse-spec (s/keys :opt-un [:etcdserverpb.messages.AuthenticateResponse/token ]))
(def AuthenticateResponse-defaults {:token "" })

(defn cis->AuthenticateResponse
  "CodedInputStream to AuthenticateResponse"
  [is]
  (->> (tag-map AuthenticateResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]
               2 [:token (cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthenticateResponse)))

(defn ecis->AuthenticateResponse
  "Embedded CodedInputStream to AuthenticateResponse"
  [is]
  (cis->embedded cis->AuthenticateResponse is))

(defn new-AuthenticateResponse
  "Creates a new instance from a map, similar to map->AuthenticateResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthenticateResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthenticateResponse-spec init))))]}
  (-> (merge AuthenticateResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (map->AuthenticateResponse)))

(defn pb->AuthenticateResponse
  "Protobuf to AuthenticateResponse"
  [input]
  (cis->AuthenticateResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; DefragmentResponse
;-----------------------------------------------------------------------------
(defrecord DefragmentResponse [header]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)))

(s/def ::DefragmentResponse-spec (s/keys :opt-un []))
(def DefragmentResponse-defaults {})

(defn cis->DefragmentResponse
  "CodedInputStream to DefragmentResponse"
  [is]
  (->> (tag-map DefragmentResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]

               [index (cis->undefined tag is)]))
         is)
        (map->DefragmentResponse)))

(defn ecis->DefragmentResponse
  "Embedded CodedInputStream to DefragmentResponse"
  [is]
  (cis->embedded cis->DefragmentResponse is))

(defn new-DefragmentResponse
  "Creates a new instance from a map, similar to map->DefragmentResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::DefragmentResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::DefragmentResponse-spec init))))]}
  (-> (merge DefragmentResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (map->DefragmentResponse)))

(defn pb->DefragmentResponse
  "Protobuf to DefragmentResponse"
  [input]
  (cis->DefragmentResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; LeaseKeepAliveResponse
;-----------------------------------------------------------------------------
(defrecord LeaseKeepAliveResponse [header ID TTL]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)
    (write-Int64 2  {:optimize true} (:ID this) os)
    (write-Int64 3  {:optimize true} (:TTL this) os)))

(s/def :etcdserverpb.messages.LeaseKeepAliveResponse/ID int?)
(s/def :etcdserverpb.messages.LeaseKeepAliveResponse/TTL int?)
(s/def ::LeaseKeepAliveResponse-spec (s/keys :opt-un [:etcdserverpb.messages.LeaseKeepAliveResponse/ID :etcdserverpb.messages.LeaseKeepAliveResponse/TTL ]))
(def LeaseKeepAliveResponse-defaults {:ID 0 :TTL 0 })

(defn cis->LeaseKeepAliveResponse
  "CodedInputStream to LeaseKeepAliveResponse"
  [is]
  (->> (tag-map LeaseKeepAliveResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]
               2 [:ID (cis->Int64 is)]
               3 [:TTL (cis->Int64 is)]

               [index (cis->undefined tag is)]))
         is)
        (map->LeaseKeepAliveResponse)))

(defn ecis->LeaseKeepAliveResponse
  "Embedded CodedInputStream to LeaseKeepAliveResponse"
  [is]
  (cis->embedded cis->LeaseKeepAliveResponse is))

(defn new-LeaseKeepAliveResponse
  "Creates a new instance from a map, similar to map->LeaseKeepAliveResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::LeaseKeepAliveResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::LeaseKeepAliveResponse-spec init))))]}
  (-> (merge LeaseKeepAliveResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (map->LeaseKeepAliveResponse)))

(defn pb->LeaseKeepAliveResponse
  "Protobuf to LeaseKeepAliveResponse"
  [input]
  (cis->LeaseKeepAliveResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; MemberAddResponse
;-----------------------------------------------------------------------------
(defrecord MemberAddResponse [header member members]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)
    (write-embedded 2 (:member this) os)
    (write-repeated write-embedded 3 (:members this) os)))

(s/def ::MemberAddResponse-spec (s/keys :opt-un []))
(def MemberAddResponse-defaults {:members [] })

(defn cis->MemberAddResponse
  "CodedInputStream to MemberAddResponse"
  [is]
  (->> (tag-map MemberAddResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]
               2 [:member (ecis->Member is)]
               3 [:members (cis->repeated ecis->Member is)]

               [index (cis->undefined tag is)]))
         is)
        (map->MemberAddResponse)))

(defn ecis->MemberAddResponse
  "Embedded CodedInputStream to MemberAddResponse"
  [is]
  (cis->embedded cis->MemberAddResponse is))

(defn new-MemberAddResponse
  "Creates a new instance from a map, similar to map->MemberAddResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::MemberAddResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::MemberAddResponse-spec init))))]}
  (-> (merge MemberAddResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (cond-> (contains? init :member) (update :member new-Member))
      (cond-> (contains? init :members) (update :members #(map new-Member %)))
      (map->MemberAddResponse)))

(defn pb->MemberAddResponse
  "Protobuf to MemberAddResponse"
  [input]
  (cis->MemberAddResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; TxnResponse
;-----------------------------------------------------------------------------
(defrecord TxnResponse [header succeeded responses]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)
    (write-Bool 2  {:optimize true} (:succeeded this) os)
    (write-repeated write-embedded 3 (:responses this) os)))

(s/def :etcdserverpb.messages.TxnResponse/succeeded boolean?)

(s/def ::TxnResponse-spec (s/keys :opt-un [:etcdserverpb.messages.TxnResponse/succeeded ]))
(def TxnResponse-defaults {:succeeded false :responses [] })

(defn cis->TxnResponse
  "CodedInputStream to TxnResponse"
  [is]
  (->> (tag-map TxnResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]
               2 [:succeeded (cis->Bool is)]
               3 [:responses (cis->repeated ecis->ResponseOp is)]

               [index (cis->undefined tag is)]))
         is)
        (map->TxnResponse)))

(defn ecis->TxnResponse
  "Embedded CodedInputStream to TxnResponse"
  [is]
  (cis->embedded cis->TxnResponse is))

(defn new-TxnResponse
  "Creates a new instance from a map, similar to map->TxnResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::TxnResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::TxnResponse-spec init))))]}
  (-> (merge TxnResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (cond-> (contains? init :responses) (update :responses #(map new-ResponseOp %)))
      (map->TxnResponse)))

(defn pb->TxnResponse
  "Protobuf to TxnResponse"
  [input]
  (cis->TxnResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; LeaseRevokeRequest
;-----------------------------------------------------------------------------
(defrecord LeaseRevokeRequest [ID]
  pb/Writer

  (serialize [this os]
    (write-Int64 1  {:optimize true} (:ID this) os)))

(s/def :etcdserverpb.messages.LeaseRevokeRequest/ID int?)
(s/def ::LeaseRevokeRequest-spec (s/keys :opt-un [:etcdserverpb.messages.LeaseRevokeRequest/ID ]))
(def LeaseRevokeRequest-defaults {:ID 0 })

(defn cis->LeaseRevokeRequest
  "CodedInputStream to LeaseRevokeRequest"
  [is]
  (->> (tag-map LeaseRevokeRequest-defaults
         (fn [tag index]
             (case index
               1 [:ID (cis->Int64 is)]

               [index (cis->undefined tag is)]))
         is)
        (map->LeaseRevokeRequest)))

(defn ecis->LeaseRevokeRequest
  "Embedded CodedInputStream to LeaseRevokeRequest"
  [is]
  (cis->embedded cis->LeaseRevokeRequest is))

(defn new-LeaseRevokeRequest
  "Creates a new instance from a map, similar to map->LeaseRevokeRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::LeaseRevokeRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::LeaseRevokeRequest-spec init))))]}
  (-> (merge LeaseRevokeRequest-defaults init)
      (map->LeaseRevokeRequest)))

(defn pb->LeaseRevokeRequest
  "Protobuf to LeaseRevokeRequest"
  [input]
  (cis->LeaseRevokeRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; MoveLeaderRequest
;-----------------------------------------------------------------------------
(defrecord MoveLeaderRequest [targetID]
  pb/Writer

  (serialize [this os]
    (write-UInt64 1  {:optimize true} (:targetID this) os)))

(s/def :etcdserverpb.messages.MoveLeaderRequest/targetID int?)
(s/def ::MoveLeaderRequest-spec (s/keys :opt-un [:etcdserverpb.messages.MoveLeaderRequest/targetID ]))
(def MoveLeaderRequest-defaults {:targetID 0 })

(defn cis->MoveLeaderRequest
  "CodedInputStream to MoveLeaderRequest"
  [is]
  (->> (tag-map MoveLeaderRequest-defaults
         (fn [tag index]
             (case index
               1 [:targetID (cis->UInt64 is)]

               [index (cis->undefined tag is)]))
         is)
        (map->MoveLeaderRequest)))

(defn ecis->MoveLeaderRequest
  "Embedded CodedInputStream to MoveLeaderRequest"
  [is]
  (cis->embedded cis->MoveLeaderRequest is))

(defn new-MoveLeaderRequest
  "Creates a new instance from a map, similar to map->MoveLeaderRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::MoveLeaderRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::MoveLeaderRequest-spec init))))]}
  (-> (merge MoveLeaderRequest-defaults init)
      (map->MoveLeaderRequest)))

(defn pb->MoveLeaderRequest
  "Protobuf to MoveLeaderRequest"
  [input]
  (cis->MoveLeaderRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthRoleGrantPermissionResponse
;-----------------------------------------------------------------------------
(defrecord AuthRoleGrantPermissionResponse [header]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)))

(s/def ::AuthRoleGrantPermissionResponse-spec (s/keys :opt-un []))
(def AuthRoleGrantPermissionResponse-defaults {})

(defn cis->AuthRoleGrantPermissionResponse
  "CodedInputStream to AuthRoleGrantPermissionResponse"
  [is]
  (->> (tag-map AuthRoleGrantPermissionResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthRoleGrantPermissionResponse)))

(defn ecis->AuthRoleGrantPermissionResponse
  "Embedded CodedInputStream to AuthRoleGrantPermissionResponse"
  [is]
  (cis->embedded cis->AuthRoleGrantPermissionResponse is))

(defn new-AuthRoleGrantPermissionResponse
  "Creates a new instance from a map, similar to map->AuthRoleGrantPermissionResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthRoleGrantPermissionResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthRoleGrantPermissionResponse-spec init))))]}
  (-> (merge AuthRoleGrantPermissionResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (map->AuthRoleGrantPermissionResponse)))

(defn pb->AuthRoleGrantPermissionResponse
  "Protobuf to AuthRoleGrantPermissionResponse"
  [input]
  (cis->AuthRoleGrantPermissionResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; LeaseKeepAliveRequest
;-----------------------------------------------------------------------------
(defrecord LeaseKeepAliveRequest [ID]
  pb/Writer

  (serialize [this os]
    (write-Int64 1  {:optimize true} (:ID this) os)))

(s/def :etcdserverpb.messages.LeaseKeepAliveRequest/ID int?)
(s/def ::LeaseKeepAliveRequest-spec (s/keys :opt-un [:etcdserverpb.messages.LeaseKeepAliveRequest/ID ]))
(def LeaseKeepAliveRequest-defaults {:ID 0 })

(defn cis->LeaseKeepAliveRequest
  "CodedInputStream to LeaseKeepAliveRequest"
  [is]
  (->> (tag-map LeaseKeepAliveRequest-defaults
         (fn [tag index]
             (case index
               1 [:ID (cis->Int64 is)]

               [index (cis->undefined tag is)]))
         is)
        (map->LeaseKeepAliveRequest)))

(defn ecis->LeaseKeepAliveRequest
  "Embedded CodedInputStream to LeaseKeepAliveRequest"
  [is]
  (cis->embedded cis->LeaseKeepAliveRequest is))

(defn new-LeaseKeepAliveRequest
  "Creates a new instance from a map, similar to map->LeaseKeepAliveRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::LeaseKeepAliveRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::LeaseKeepAliveRequest-spec init))))]}
  (-> (merge LeaseKeepAliveRequest-defaults init)
      (map->LeaseKeepAliveRequest)))

(defn pb->LeaseKeepAliveRequest
  "Protobuf to LeaseKeepAliveRequest"
  [input]
  (cis->LeaseKeepAliveRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; HashResponse
;-----------------------------------------------------------------------------
(defrecord HashResponse [header hash]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)
    (write-UInt32 2  {:optimize true} (:hash this) os)))

(s/def :etcdserverpb.messages.HashResponse/hash int?)
(s/def ::HashResponse-spec (s/keys :opt-un [:etcdserverpb.messages.HashResponse/hash ]))
(def HashResponse-defaults {:hash 0 })

(defn cis->HashResponse
  "CodedInputStream to HashResponse"
  [is]
  (->> (tag-map HashResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]
               2 [:hash (cis->UInt32 is)]

               [index (cis->undefined tag is)]))
         is)
        (map->HashResponse)))

(defn ecis->HashResponse
  "Embedded CodedInputStream to HashResponse"
  [is]
  (cis->embedded cis->HashResponse is))

(defn new-HashResponse
  "Creates a new instance from a map, similar to map->HashResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::HashResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::HashResponse-spec init))))]}
  (-> (merge HashResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (map->HashResponse)))

(defn pb->HashResponse
  "Protobuf to HashResponse"
  [input]
  (cis->HashResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; LeaseTimeToLiveResponse
;-----------------------------------------------------------------------------
(defrecord LeaseTimeToLiveResponse [header ID TTL grantedTTL keys]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)
    (write-Int64 2  {:optimize true} (:ID this) os)
    (write-Int64 3  {:optimize true} (:TTL this) os)
    (write-Int64 4  {:optimize true} (:grantedTTL this) os)
    (write-repeated write-Bytes 5 (:keys this) os)))

(s/def :etcdserverpb.messages.LeaseTimeToLiveResponse/ID int?)
(s/def :etcdserverpb.messages.LeaseTimeToLiveResponse/TTL int?)
(s/def :etcdserverpb.messages.LeaseTimeToLiveResponse/grantedTTL int?)
(s/def :etcdserverpb.messages.LeaseTimeToLiveResponse/keys (s/every bytes?))
(s/def ::LeaseTimeToLiveResponse-spec (s/keys :opt-un [:etcdserverpb.messages.LeaseTimeToLiveResponse/ID :etcdserverpb.messages.LeaseTimeToLiveResponse/TTL :etcdserverpb.messages.LeaseTimeToLiveResponse/grantedTTL :etcdserverpb.messages.LeaseTimeToLiveResponse/keys ]))
(def LeaseTimeToLiveResponse-defaults {:ID 0 :TTL 0 :grantedTTL 0 :keys [] })

(defn cis->LeaseTimeToLiveResponse
  "CodedInputStream to LeaseTimeToLiveResponse"
  [is]
  (->> (tag-map LeaseTimeToLiveResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]
               2 [:ID (cis->Int64 is)]
               3 [:TTL (cis->Int64 is)]
               4 [:grantedTTL (cis->Int64 is)]
               5 [:keys (cis->repeated cis->Bytes is)]

               [index (cis->undefined tag is)]))
         is)
        (map->LeaseTimeToLiveResponse)))

(defn ecis->LeaseTimeToLiveResponse
  "Embedded CodedInputStream to LeaseTimeToLiveResponse"
  [is]
  (cis->embedded cis->LeaseTimeToLiveResponse is))

(defn new-LeaseTimeToLiveResponse
  "Creates a new instance from a map, similar to map->LeaseTimeToLiveResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::LeaseTimeToLiveResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::LeaseTimeToLiveResponse-spec init))))]}
  (-> (merge LeaseTimeToLiveResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (map->LeaseTimeToLiveResponse)))

(defn pb->LeaseTimeToLiveResponse
  "Protobuf to LeaseTimeToLiveResponse"
  [input]
  (cis->LeaseTimeToLiveResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; PutRequest
;-----------------------------------------------------------------------------
(defrecord PutRequest [key value lease prev-kv ignore-value ignore-lease]
  pb/Writer

  (serialize [this os]
    (write-Bytes 1  {:optimize true} (:key this) os)
    (write-Bytes 2  {:optimize true} (:value this) os)
    (write-Int64 3  {:optimize true} (:lease this) os)
    (write-Bool 4  {:optimize true} (:prev-kv this) os)
    (write-Bool 5  {:optimize true} (:ignore-value this) os)
    (write-Bool 6  {:optimize true} (:ignore-lease this) os)))

(s/def :etcdserverpb.messages.PutRequest/key bytes?)
(s/def :etcdserverpb.messages.PutRequest/value bytes?)
(s/def :etcdserverpb.messages.PutRequest/lease int?)
(s/def :etcdserverpb.messages.PutRequest/prev-kv boolean?)
(s/def :etcdserverpb.messages.PutRequest/ignore-value boolean?)
(s/def :etcdserverpb.messages.PutRequest/ignore-lease boolean?)
(s/def ::PutRequest-spec (s/keys :opt-un [:etcdserverpb.messages.PutRequest/key :etcdserverpb.messages.PutRequest/value :etcdserverpb.messages.PutRequest/lease :etcdserverpb.messages.PutRequest/prev-kv :etcdserverpb.messages.PutRequest/ignore-value :etcdserverpb.messages.PutRequest/ignore-lease ]))
(def PutRequest-defaults {:key (byte-array 0) :value (byte-array 0) :lease 0 :prev-kv false :ignore-value false :ignore-lease false })

(defn cis->PutRequest
  "CodedInputStream to PutRequest"
  [is]
  (->> (tag-map PutRequest-defaults
         (fn [tag index]
             (case index
               1 [:key (cis->Bytes is)]
               2 [:value (cis->Bytes is)]
               3 [:lease (cis->Int64 is)]
               4 [:prev-kv (cis->Bool is)]
               5 [:ignore-value (cis->Bool is)]
               6 [:ignore-lease (cis->Bool is)]

               [index (cis->undefined tag is)]))
         is)
        (map->PutRequest)))

(defn ecis->PutRequest
  "Embedded CodedInputStream to PutRequest"
  [is]
  (cis->embedded cis->PutRequest is))

(defn new-PutRequest
  "Creates a new instance from a map, similar to map->PutRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::PutRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::PutRequest-spec init))))]}
  (-> (merge PutRequest-defaults init)
      (map->PutRequest)))

(defn pb->PutRequest
  "Protobuf to PutRequest"
  [input]
  (cis->PutRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthRoleListRequest
;-----------------------------------------------------------------------------
(defrecord AuthRoleListRequest []
  pb/Writer

  (serialize [this os]
))

(s/def ::AuthRoleListRequest-spec (s/keys :opt-un []))
(def AuthRoleListRequest-defaults {})

(defn cis->AuthRoleListRequest
  "CodedInputStream to AuthRoleListRequest"
  [is]
  (->> (tag-map AuthRoleListRequest-defaults
         (fn [tag index]
             (case index
               [index (cis->undefined tag is)]))
         is)
        (map->AuthRoleListRequest)))

(defn ecis->AuthRoleListRequest
  "Embedded CodedInputStream to AuthRoleListRequest"
  [is]
  (cis->embedded cis->AuthRoleListRequest is))

(defn new-AuthRoleListRequest
  "Creates a new instance from a map, similar to map->AuthRoleListRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthRoleListRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthRoleListRequest-spec init))))]}
  (-> (merge AuthRoleListRequest-defaults init)
      (map->AuthRoleListRequest)))

(defn pb->AuthRoleListRequest
  "Protobuf to AuthRoleListRequest"
  [input]
  (cis->AuthRoleListRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthDisableResponse
;-----------------------------------------------------------------------------
(defrecord AuthDisableResponse [header]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)))

(s/def ::AuthDisableResponse-spec (s/keys :opt-un []))
(def AuthDisableResponse-defaults {})

(defn cis->AuthDisableResponse
  "CodedInputStream to AuthDisableResponse"
  [is]
  (->> (tag-map AuthDisableResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthDisableResponse)))

(defn ecis->AuthDisableResponse
  "Embedded CodedInputStream to AuthDisableResponse"
  [is]
  (cis->embedded cis->AuthDisableResponse is))

(defn new-AuthDisableResponse
  "Creates a new instance from a map, similar to map->AuthDisableResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthDisableResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthDisableResponse-spec init))))]}
  (-> (merge AuthDisableResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (map->AuthDisableResponse)))

(defn pb->AuthDisableResponse
  "Protobuf to AuthDisableResponse"
  [input]
  (cis->AuthDisableResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthEnableResponse
;-----------------------------------------------------------------------------
(defrecord AuthEnableResponse [header]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)))

(s/def ::AuthEnableResponse-spec (s/keys :opt-un []))
(def AuthEnableResponse-defaults {})

(defn cis->AuthEnableResponse
  "CodedInputStream to AuthEnableResponse"
  [is]
  (->> (tag-map AuthEnableResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthEnableResponse)))

(defn ecis->AuthEnableResponse
  "Embedded CodedInputStream to AuthEnableResponse"
  [is]
  (cis->embedded cis->AuthEnableResponse is))

(defn new-AuthEnableResponse
  "Creates a new instance from a map, similar to map->AuthEnableResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthEnableResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthEnableResponse-spec init))))]}
  (-> (merge AuthEnableResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (map->AuthEnableResponse)))

(defn pb->AuthEnableResponse
  "Protobuf to AuthEnableResponse"
  [input]
  (cis->AuthEnableResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; TxnRequest
;-----------------------------------------------------------------------------
(defrecord TxnRequest [compare success failure]
  pb/Writer

  (serialize [this os]
    (write-repeated write-embedded 1 (:compare this) os)
    (write-repeated write-embedded 2 (:success this) os)
    (write-repeated write-embedded 3 (:failure this) os)))

(s/def ::TxnRequest-spec (s/keys :opt-un []))
(def TxnRequest-defaults {:compare [] :success [] :failure [] })

(defn cis->TxnRequest
  "CodedInputStream to TxnRequest"
  [is]
  (->> (tag-map TxnRequest-defaults
         (fn [tag index]
             (case index
               1 [:compare (cis->repeated ecis->Compare is)]
               2 [:success (cis->repeated ecis->RequestOp is)]
               3 [:failure (cis->repeated ecis->RequestOp is)]

               [index (cis->undefined tag is)]))
         is)
        (map->TxnRequest)))

(defn ecis->TxnRequest
  "Embedded CodedInputStream to TxnRequest"
  [is]
  (cis->embedded cis->TxnRequest is))

(defn new-TxnRequest
  "Creates a new instance from a map, similar to map->TxnRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::TxnRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::TxnRequest-spec init))))]}
  (-> (merge TxnRequest-defaults init)
      (cond-> (contains? init :compare) (update :compare #(map new-Compare %)))
      (cond-> (contains? init :success) (update :success #(map new-RequestOp %)))
      (cond-> (contains? init :failure) (update :failure #(map new-RequestOp %)))
      (map->TxnRequest)))

(defn pb->TxnRequest
  "Protobuf to TxnRequest"
  [input]
  (cis->TxnRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; StatusRequest
;-----------------------------------------------------------------------------
(defrecord StatusRequest []
  pb/Writer

  (serialize [this os]
))

(s/def ::StatusRequest-spec (s/keys :opt-un []))
(def StatusRequest-defaults {})

(defn cis->StatusRequest
  "CodedInputStream to StatusRequest"
  [is]
  (->> (tag-map StatusRequest-defaults
         (fn [tag index]
             (case index
               [index (cis->undefined tag is)]))
         is)
        (map->StatusRequest)))

(defn ecis->StatusRequest
  "Embedded CodedInputStream to StatusRequest"
  [is]
  (cis->embedded cis->StatusRequest is))

(defn new-StatusRequest
  "Creates a new instance from a map, similar to map->StatusRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::StatusRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::StatusRequest-spec init))))]}
  (-> (merge StatusRequest-defaults init)
      (map->StatusRequest)))

(defn pb->StatusRequest
  "Protobuf to StatusRequest"
  [input]
  (cis->StatusRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthRoleRevokePermissionResponse
;-----------------------------------------------------------------------------
(defrecord AuthRoleRevokePermissionResponse [header]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)))

(s/def ::AuthRoleRevokePermissionResponse-spec (s/keys :opt-un []))
(def AuthRoleRevokePermissionResponse-defaults {})

(defn cis->AuthRoleRevokePermissionResponse
  "CodedInputStream to AuthRoleRevokePermissionResponse"
  [is]
  (->> (tag-map AuthRoleRevokePermissionResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthRoleRevokePermissionResponse)))

(defn ecis->AuthRoleRevokePermissionResponse
  "Embedded CodedInputStream to AuthRoleRevokePermissionResponse"
  [is]
  (cis->embedded cis->AuthRoleRevokePermissionResponse is))

(defn new-AuthRoleRevokePermissionResponse
  "Creates a new instance from a map, similar to map->AuthRoleRevokePermissionResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthRoleRevokePermissionResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthRoleRevokePermissionResponse-spec init))))]}
  (-> (merge AuthRoleRevokePermissionResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (map->AuthRoleRevokePermissionResponse)))

(defn pb->AuthRoleRevokePermissionResponse
  "Protobuf to AuthRoleRevokePermissionResponse"
  [input]
  (cis->AuthRoleRevokePermissionResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthEnableRequest
;-----------------------------------------------------------------------------
(defrecord AuthEnableRequest []
  pb/Writer

  (serialize [this os]
))

(s/def ::AuthEnableRequest-spec (s/keys :opt-un []))
(def AuthEnableRequest-defaults {})

(defn cis->AuthEnableRequest
  "CodedInputStream to AuthEnableRequest"
  [is]
  (->> (tag-map AuthEnableRequest-defaults
         (fn [tag index]
             (case index
               [index (cis->undefined tag is)]))
         is)
        (map->AuthEnableRequest)))

(defn ecis->AuthEnableRequest
  "Embedded CodedInputStream to AuthEnableRequest"
  [is]
  (cis->embedded cis->AuthEnableRequest is))

(defn new-AuthEnableRequest
  "Creates a new instance from a map, similar to map->AuthEnableRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthEnableRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthEnableRequest-spec init))))]}
  (-> (merge AuthEnableRequest-defaults init)
      (map->AuthEnableRequest)))

(defn pb->AuthEnableRequest
  "Protobuf to AuthEnableRequest"
  [input]
  (cis->AuthEnableRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; MemberListResponse
;-----------------------------------------------------------------------------
(defrecord MemberListResponse [header members]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)
    (write-repeated write-embedded 2 (:members this) os)))

(s/def ::MemberListResponse-spec (s/keys :opt-un []))
(def MemberListResponse-defaults {:members [] })

(defn cis->MemberListResponse
  "CodedInputStream to MemberListResponse"
  [is]
  (->> (tag-map MemberListResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]
               2 [:members (cis->repeated ecis->Member is)]

               [index (cis->undefined tag is)]))
         is)
        (map->MemberListResponse)))

(defn ecis->MemberListResponse
  "Embedded CodedInputStream to MemberListResponse"
  [is]
  (cis->embedded cis->MemberListResponse is))

(defn new-MemberListResponse
  "Creates a new instance from a map, similar to map->MemberListResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::MemberListResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::MemberListResponse-spec init))))]}
  (-> (merge MemberListResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (cond-> (contains? init :members) (update :members #(map new-Member %)))
      (map->MemberListResponse)))

(defn pb->MemberListResponse
  "Protobuf to MemberListResponse"
  [input]
  (cis->MemberListResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthRoleAddRequest
;-----------------------------------------------------------------------------
(defrecord AuthRoleAddRequest [name]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:name this) os)))

(s/def :etcdserverpb.messages.AuthRoleAddRequest/name string?)
(s/def ::AuthRoleAddRequest-spec (s/keys :opt-un [:etcdserverpb.messages.AuthRoleAddRequest/name ]))
(def AuthRoleAddRequest-defaults {:name "" })

(defn cis->AuthRoleAddRequest
  "CodedInputStream to AuthRoleAddRequest"
  [is]
  (->> (tag-map AuthRoleAddRequest-defaults
         (fn [tag index]
             (case index
               1 [:name (cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthRoleAddRequest)))

(defn ecis->AuthRoleAddRequest
  "Embedded CodedInputStream to AuthRoleAddRequest"
  [is]
  (cis->embedded cis->AuthRoleAddRequest is))

(defn new-AuthRoleAddRequest
  "Creates a new instance from a map, similar to map->AuthRoleAddRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthRoleAddRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthRoleAddRequest-spec init))))]}
  (-> (merge AuthRoleAddRequest-defaults init)
      (map->AuthRoleAddRequest)))

(defn pb->AuthRoleAddRequest
  "Protobuf to AuthRoleAddRequest"
  [input]
  (cis->AuthRoleAddRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; Compare
;-----------------------------------------------------------------------------
(defrecord Compare [result target key target-union range-end]
  pb/Writer

  (serialize [this os]
    (write-Compare-CompareResult 1  {:optimize true} (:result this) os)
    (write-Compare-CompareTarget 2  {:optimize true} (:target this) os)
    (write-Bytes 3  {:optimize true} (:key this) os)
    (write-target-union  (:target-union this) os)
    (write-Bytes 8  {:optimize true} (:range-end this) os)))

(s/def :etcdserverpb.messages.Compare/result (s/or :keyword keyword? :int int?))
(s/def :etcdserverpb.messages.Compare/target (s/or :keyword keyword? :int int?))
(s/def :etcdserverpb.messages.Compare/key bytes?)

(s/def :etcdserverpb.messages.Compare/range-end bytes?)
(s/def ::Compare-spec (s/keys :opt-un [:etcdserverpb.messages.Compare/result :etcdserverpb.messages.Compare/target :etcdserverpb.messages.Compare/key :etcdserverpb.messages.Compare/range-end ]))
(def Compare-defaults {:result (Compare-CompareResult-val2label 0) :target (Compare-CompareTarget-val2label 0) :key (byte-array 0) :range-end (byte-array 0) })

(defn cis->Compare
  "CodedInputStream to Compare"
  [is]
  (->> (tag-map Compare-defaults
         (fn [tag index]
             (case index
               1 [:result (cis->Compare-CompareResult is)]
               2 [:target (cis->Compare-CompareTarget is)]
               3 [:key (cis->Bytes is)]
               4 [:target-union {:version (cis->Int64 is)}]
               5 [:target-union {:create-revision (cis->Int64 is)}]
               6 [:target-union {:mod-revision (cis->Int64 is)}]
               7 [:target-union {:value (cis->Bytes is)}]
               8 [:range-end (cis->Bytes is)]

               [index (cis->undefined tag is)]))
         is)
        (map->Compare)))

(defn ecis->Compare
  "Embedded CodedInputStream to Compare"
  [is]
  (cis->embedded cis->Compare is))

(defn new-Compare
  "Creates a new instance from a map, similar to map->Compare except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Compare-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Compare-spec init))))]}
  (-> (merge Compare-defaults init)
      (convert-target-union)
      (map->Compare)))

(defn pb->Compare
  "Protobuf to Compare"
  [input]
  (cis->Compare (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthRoleAddResponse
;-----------------------------------------------------------------------------
(defrecord AuthRoleAddResponse [header]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)))

(s/def ::AuthRoleAddResponse-spec (s/keys :opt-un []))
(def AuthRoleAddResponse-defaults {})

(defn cis->AuthRoleAddResponse
  "CodedInputStream to AuthRoleAddResponse"
  [is]
  (->> (tag-map AuthRoleAddResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthRoleAddResponse)))

(defn ecis->AuthRoleAddResponse
  "Embedded CodedInputStream to AuthRoleAddResponse"
  [is]
  (cis->embedded cis->AuthRoleAddResponse is))

(defn new-AuthRoleAddResponse
  "Creates a new instance from a map, similar to map->AuthRoleAddResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthRoleAddResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthRoleAddResponse-spec init))))]}
  (-> (merge AuthRoleAddResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (map->AuthRoleAddResponse)))

(defn pb->AuthRoleAddResponse
  "Protobuf to AuthRoleAddResponse"
  [input]
  (cis->AuthRoleAddResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; MemberRemoveRequest
;-----------------------------------------------------------------------------
(defrecord MemberRemoveRequest [ID]
  pb/Writer

  (serialize [this os]
    (write-UInt64 1  {:optimize true} (:ID this) os)))

(s/def :etcdserverpb.messages.MemberRemoveRequest/ID int?)
(s/def ::MemberRemoveRequest-spec (s/keys :opt-un [:etcdserverpb.messages.MemberRemoveRequest/ID ]))
(def MemberRemoveRequest-defaults {:ID 0 })

(defn cis->MemberRemoveRequest
  "CodedInputStream to MemberRemoveRequest"
  [is]
  (->> (tag-map MemberRemoveRequest-defaults
         (fn [tag index]
             (case index
               1 [:ID (cis->UInt64 is)]

               [index (cis->undefined tag is)]))
         is)
        (map->MemberRemoveRequest)))

(defn ecis->MemberRemoveRequest
  "Embedded CodedInputStream to MemberRemoveRequest"
  [is]
  (cis->embedded cis->MemberRemoveRequest is))

(defn new-MemberRemoveRequest
  "Creates a new instance from a map, similar to map->MemberRemoveRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::MemberRemoveRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::MemberRemoveRequest-spec init))))]}
  (-> (merge MemberRemoveRequest-defaults init)
      (map->MemberRemoveRequest)))

(defn pb->MemberRemoveRequest
  "Protobuf to MemberRemoveRequest"
  [input]
  (cis->MemberRemoveRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; RequestOp
;-----------------------------------------------------------------------------
(defrecord RequestOp [request]
  pb/Writer

  (serialize [this os]
    (write-request  (:request this) os)))

(s/def ::RequestOp-spec (s/keys :opt-un []))
(def RequestOp-defaults {})

(defn cis->RequestOp
  "CodedInputStream to RequestOp"
  [is]
  (->> (tag-map RequestOp-defaults
         (fn [tag index]
             (case index
               1 [:request {:request-range (ecis->RangeRequest is)}]
               2 [:request {:request-put (ecis->PutRequest is)}]
               3 [:request {:request-delete-range (ecis->DeleteRangeRequest is)}]
               4 [:request {:request-txn (ecis->TxnRequest is)}]

               [index (cis->undefined tag is)]))
         is)
        (map->RequestOp)))

(defn ecis->RequestOp
  "Embedded CodedInputStream to RequestOp"
  [is]
  (cis->embedded cis->RequestOp is))

(defn new-RequestOp
  "Creates a new instance from a map, similar to map->RequestOp except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::RequestOp-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::RequestOp-spec init))))]}
  (-> (merge RequestOp-defaults init)
      (convert-request)
      (map->RequestOp)))

(defn pb->RequestOp
  "Protobuf to RequestOp"
  [input]
  (cis->RequestOp (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthRoleGetResponse
;-----------------------------------------------------------------------------
(defrecord AuthRoleGetResponse [header perm]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)
    (write-repeated write-embedded 2 (:perm this) os)))

(s/def ::AuthRoleGetResponse-spec (s/keys :opt-un []))
(def AuthRoleGetResponse-defaults {:perm [] })

(defn cis->AuthRoleGetResponse
  "CodedInputStream to AuthRoleGetResponse"
  [is]
  (->> (tag-map AuthRoleGetResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]
               2 [:perm (cis->repeated authpb/ecis->Permission is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthRoleGetResponse)))

(defn ecis->AuthRoleGetResponse
  "Embedded CodedInputStream to AuthRoleGetResponse"
  [is]
  (cis->embedded cis->AuthRoleGetResponse is))

(defn new-AuthRoleGetResponse
  "Creates a new instance from a map, similar to map->AuthRoleGetResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthRoleGetResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthRoleGetResponse-spec init))))]}
  (-> (merge AuthRoleGetResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (cond-> (contains? init :perm) (update :perm #(map authpb/new-Permission %)))
      (map->AuthRoleGetResponse)))

(defn pb->AuthRoleGetResponse
  "Protobuf to AuthRoleGetResponse"
  [input]
  (cis->AuthRoleGetResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; SnapshotResponse
;-----------------------------------------------------------------------------
(defrecord SnapshotResponse [header remaining-bytes blob]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)
    (write-UInt64 2  {:optimize true} (:remaining-bytes this) os)
    (write-Bytes 3  {:optimize true} (:blob this) os)))

(s/def :etcdserverpb.messages.SnapshotResponse/remaining-bytes int?)
(s/def :etcdserverpb.messages.SnapshotResponse/blob bytes?)
(s/def ::SnapshotResponse-spec (s/keys :opt-un [:etcdserverpb.messages.SnapshotResponse/remaining-bytes :etcdserverpb.messages.SnapshotResponse/blob ]))
(def SnapshotResponse-defaults {:remaining-bytes 0 :blob (byte-array 0) })

(defn cis->SnapshotResponse
  "CodedInputStream to SnapshotResponse"
  [is]
  (->> (tag-map SnapshotResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]
               2 [:remaining-bytes (cis->UInt64 is)]
               3 [:blob (cis->Bytes is)]

               [index (cis->undefined tag is)]))
         is)
        (map->SnapshotResponse)))

(defn ecis->SnapshotResponse
  "Embedded CodedInputStream to SnapshotResponse"
  [is]
  (cis->embedded cis->SnapshotResponse is))

(defn new-SnapshotResponse
  "Creates a new instance from a map, similar to map->SnapshotResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::SnapshotResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::SnapshotResponse-spec init))))]}
  (-> (merge SnapshotResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (map->SnapshotResponse)))

(defn pb->SnapshotResponse
  "Protobuf to SnapshotResponse"
  [input]
  (cis->SnapshotResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthUserListRequest
;-----------------------------------------------------------------------------
(defrecord AuthUserListRequest []
  pb/Writer

  (serialize [this os]
))

(s/def ::AuthUserListRequest-spec (s/keys :opt-un []))
(def AuthUserListRequest-defaults {})

(defn cis->AuthUserListRequest
  "CodedInputStream to AuthUserListRequest"
  [is]
  (->> (tag-map AuthUserListRequest-defaults
         (fn [tag index]
             (case index
               [index (cis->undefined tag is)]))
         is)
        (map->AuthUserListRequest)))

(defn ecis->AuthUserListRequest
  "Embedded CodedInputStream to AuthUserListRequest"
  [is]
  (cis->embedded cis->AuthUserListRequest is))

(defn new-AuthUserListRequest
  "Creates a new instance from a map, similar to map->AuthUserListRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthUserListRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthUserListRequest-spec init))))]}
  (-> (merge AuthUserListRequest-defaults init)
      (map->AuthUserListRequest)))

(defn pb->AuthUserListRequest
  "Protobuf to AuthUserListRequest"
  [input]
  (cis->AuthUserListRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; LeaseRevokeResponse
;-----------------------------------------------------------------------------
(defrecord LeaseRevokeResponse [header]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)))

(s/def ::LeaseRevokeResponse-spec (s/keys :opt-un []))
(def LeaseRevokeResponse-defaults {})

(defn cis->LeaseRevokeResponse
  "CodedInputStream to LeaseRevokeResponse"
  [is]
  (->> (tag-map LeaseRevokeResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]

               [index (cis->undefined tag is)]))
         is)
        (map->LeaseRevokeResponse)))

(defn ecis->LeaseRevokeResponse
  "Embedded CodedInputStream to LeaseRevokeResponse"
  [is]
  (cis->embedded cis->LeaseRevokeResponse is))

(defn new-LeaseRevokeResponse
  "Creates a new instance from a map, similar to map->LeaseRevokeResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::LeaseRevokeResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::LeaseRevokeResponse-spec init))))]}
  (-> (merge LeaseRevokeResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (map->LeaseRevokeResponse)))

(defn pb->LeaseRevokeResponse
  "Protobuf to LeaseRevokeResponse"
  [input]
  (cis->LeaseRevokeResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthRoleGetRequest
;-----------------------------------------------------------------------------
(defrecord AuthRoleGetRequest [role]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:role this) os)))

(s/def :etcdserverpb.messages.AuthRoleGetRequest/role string?)
(s/def ::AuthRoleGetRequest-spec (s/keys :opt-un [:etcdserverpb.messages.AuthRoleGetRequest/role ]))
(def AuthRoleGetRequest-defaults {:role "" })

(defn cis->AuthRoleGetRequest
  "CodedInputStream to AuthRoleGetRequest"
  [is]
  (->> (tag-map AuthRoleGetRequest-defaults
         (fn [tag index]
             (case index
               1 [:role (cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthRoleGetRequest)))

(defn ecis->AuthRoleGetRequest
  "Embedded CodedInputStream to AuthRoleGetRequest"
  [is]
  (cis->embedded cis->AuthRoleGetRequest is))

(defn new-AuthRoleGetRequest
  "Creates a new instance from a map, similar to map->AuthRoleGetRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthRoleGetRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthRoleGetRequest-spec init))))]}
  (-> (merge AuthRoleGetRequest-defaults init)
      (map->AuthRoleGetRequest)))

(defn pb->AuthRoleGetRequest
  "Protobuf to AuthRoleGetRequest"
  [input]
  (cis->AuthRoleGetRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; HashKVRequest
;-----------------------------------------------------------------------------
(defrecord HashKVRequest [revision]
  pb/Writer

  (serialize [this os]
    (write-Int64 1  {:optimize true} (:revision this) os)))

(s/def :etcdserverpb.messages.HashKVRequest/revision int?)
(s/def ::HashKVRequest-spec (s/keys :opt-un [:etcdserverpb.messages.HashKVRequest/revision ]))
(def HashKVRequest-defaults {:revision 0 })

(defn cis->HashKVRequest
  "CodedInputStream to HashKVRequest"
  [is]
  (->> (tag-map HashKVRequest-defaults
         (fn [tag index]
             (case index
               1 [:revision (cis->Int64 is)]

               [index (cis->undefined tag is)]))
         is)
        (map->HashKVRequest)))

(defn ecis->HashKVRequest
  "Embedded CodedInputStream to HashKVRequest"
  [is]
  (cis->embedded cis->HashKVRequest is))

(defn new-HashKVRequest
  "Creates a new instance from a map, similar to map->HashKVRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::HashKVRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::HashKVRequest-spec init))))]}
  (-> (merge HashKVRequest-defaults init)
      (map->HashKVRequest)))

(defn pb->HashKVRequest
  "Protobuf to HashKVRequest"
  [input]
  (cis->HashKVRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthDisableRequest
;-----------------------------------------------------------------------------
(defrecord AuthDisableRequest []
  pb/Writer

  (serialize [this os]
))

(s/def ::AuthDisableRequest-spec (s/keys :opt-un []))
(def AuthDisableRequest-defaults {})

(defn cis->AuthDisableRequest
  "CodedInputStream to AuthDisableRequest"
  [is]
  (->> (tag-map AuthDisableRequest-defaults
         (fn [tag index]
             (case index
               [index (cis->undefined tag is)]))
         is)
        (map->AuthDisableRequest)))

(defn ecis->AuthDisableRequest
  "Embedded CodedInputStream to AuthDisableRequest"
  [is]
  (cis->embedded cis->AuthDisableRequest is))

(defn new-AuthDisableRequest
  "Creates a new instance from a map, similar to map->AuthDisableRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthDisableRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthDisableRequest-spec init))))]}
  (-> (merge AuthDisableRequest-defaults init)
      (map->AuthDisableRequest)))

(defn pb->AuthDisableRequest
  "Protobuf to AuthDisableRequest"
  [input]
  (cis->AuthDisableRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthUserGetResponse
;-----------------------------------------------------------------------------
(defrecord AuthUserGetResponse [header roles]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)
    (write-repeated write-String 2 (:roles this) os)))

(s/def :etcdserverpb.messages.AuthUserGetResponse/roles (s/every string?))
(s/def ::AuthUserGetResponse-spec (s/keys :opt-un [:etcdserverpb.messages.AuthUserGetResponse/roles ]))
(def AuthUserGetResponse-defaults {:roles [] })

(defn cis->AuthUserGetResponse
  "CodedInputStream to AuthUserGetResponse"
  [is]
  (->> (tag-map AuthUserGetResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]
               2 [:roles (cis->repeated cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthUserGetResponse)))

(defn ecis->AuthUserGetResponse
  "Embedded CodedInputStream to AuthUserGetResponse"
  [is]
  (cis->embedded cis->AuthUserGetResponse is))

(defn new-AuthUserGetResponse
  "Creates a new instance from a map, similar to map->AuthUserGetResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthUserGetResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthUserGetResponse-spec init))))]}
  (-> (merge AuthUserGetResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (map->AuthUserGetResponse)))

(defn pb->AuthUserGetResponse
  "Protobuf to AuthUserGetResponse"
  [input]
  (cis->AuthUserGetResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthUserGrantRoleRequest
;-----------------------------------------------------------------------------
(defrecord AuthUserGrantRoleRequest [user role]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:user this) os)
    (write-String 2  {:optimize true} (:role this) os)))

(s/def :etcdserverpb.messages.AuthUserGrantRoleRequest/user string?)
(s/def :etcdserverpb.messages.AuthUserGrantRoleRequest/role string?)
(s/def ::AuthUserGrantRoleRequest-spec (s/keys :opt-un [:etcdserverpb.messages.AuthUserGrantRoleRequest/user :etcdserverpb.messages.AuthUserGrantRoleRequest/role ]))
(def AuthUserGrantRoleRequest-defaults {:user "" :role "" })

(defn cis->AuthUserGrantRoleRequest
  "CodedInputStream to AuthUserGrantRoleRequest"
  [is]
  (->> (tag-map AuthUserGrantRoleRequest-defaults
         (fn [tag index]
             (case index
               1 [:user (cis->String is)]
               2 [:role (cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthUserGrantRoleRequest)))

(defn ecis->AuthUserGrantRoleRequest
  "Embedded CodedInputStream to AuthUserGrantRoleRequest"
  [is]
  (cis->embedded cis->AuthUserGrantRoleRequest is))

(defn new-AuthUserGrantRoleRequest
  "Creates a new instance from a map, similar to map->AuthUserGrantRoleRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthUserGrantRoleRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthUserGrantRoleRequest-spec init))))]}
  (-> (merge AuthUserGrantRoleRequest-defaults init)
      (map->AuthUserGrantRoleRequest)))

(defn pb->AuthUserGrantRoleRequest
  "Protobuf to AuthUserGrantRoleRequest"
  [input]
  (cis->AuthUserGrantRoleRequest (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthUserChangePasswordResponse
;-----------------------------------------------------------------------------
(defrecord AuthUserChangePasswordResponse [header]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)))

(s/def ::AuthUserChangePasswordResponse-spec (s/keys :opt-un []))
(def AuthUserChangePasswordResponse-defaults {})

(defn cis->AuthUserChangePasswordResponse
  "CodedInputStream to AuthUserChangePasswordResponse"
  [is]
  (->> (tag-map AuthUserChangePasswordResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthUserChangePasswordResponse)))

(defn ecis->AuthUserChangePasswordResponse
  "Embedded CodedInputStream to AuthUserChangePasswordResponse"
  [is]
  (cis->embedded cis->AuthUserChangePasswordResponse is))

(defn new-AuthUserChangePasswordResponse
  "Creates a new instance from a map, similar to map->AuthUserChangePasswordResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthUserChangePasswordResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthUserChangePasswordResponse-spec init))))]}
  (-> (merge AuthUserChangePasswordResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (map->AuthUserChangePasswordResponse)))

(defn pb->AuthUserChangePasswordResponse
  "Protobuf to AuthUserChangePasswordResponse"
  [input]
  (cis->AuthUserChangePasswordResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; WatchResponse
;-----------------------------------------------------------------------------
(defrecord WatchResponse [header watch-id created canceled compact-revision cancel-reason events]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)
    (write-Int64 2  {:optimize true} (:watch-id this) os)
    (write-Bool 3  {:optimize true} (:created this) os)
    (write-Bool 4  {:optimize true} (:canceled this) os)
    (write-Int64 5  {:optimize true} (:compact-revision this) os)
    (write-String 6  {:optimize true} (:cancel-reason this) os)
    (write-repeated write-embedded 11 (:events this) os)))

(s/def :etcdserverpb.messages.WatchResponse/watch-id int?)
(s/def :etcdserverpb.messages.WatchResponse/created boolean?)
(s/def :etcdserverpb.messages.WatchResponse/canceled boolean?)
(s/def :etcdserverpb.messages.WatchResponse/compact-revision int?)
(s/def :etcdserverpb.messages.WatchResponse/cancel-reason string?)

(s/def ::WatchResponse-spec (s/keys :opt-un [:etcdserverpb.messages.WatchResponse/watch-id :etcdserverpb.messages.WatchResponse/created :etcdserverpb.messages.WatchResponse/canceled :etcdserverpb.messages.WatchResponse/compact-revision :etcdserverpb.messages.WatchResponse/cancel-reason ]))
(def WatchResponse-defaults {:watch-id 0 :created false :canceled false :compact-revision 0 :cancel-reason "" :events [] })

(defn cis->WatchResponse
  "CodedInputStream to WatchResponse"
  [is]
  (->> (tag-map WatchResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]
               2 [:watch-id (cis->Int64 is)]
               3 [:created (cis->Bool is)]
               4 [:canceled (cis->Bool is)]
               5 [:compact-revision (cis->Int64 is)]
               6 [:cancel-reason (cis->String is)]
               11 [:events (cis->repeated mvccpb/ecis->Event is)]

               [index (cis->undefined tag is)]))
         is)
        (map->WatchResponse)))

(defn ecis->WatchResponse
  "Embedded CodedInputStream to WatchResponse"
  [is]
  (cis->embedded cis->WatchResponse is))

(defn new-WatchResponse
  "Creates a new instance from a map, similar to map->WatchResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::WatchResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::WatchResponse-spec init))))]}
  (-> (merge WatchResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (cond-> (contains? init :events) (update :events #(map mvccpb/new-Event %)))
      (map->WatchResponse)))

(defn pb->WatchResponse
  "Protobuf to WatchResponse"
  [input]
  (cis->WatchResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthUserDeleteResponse
;-----------------------------------------------------------------------------
(defrecord AuthUserDeleteResponse [header]
  pb/Writer

  (serialize [this os]
    (write-embedded 1 (:header this) os)))

(s/def ::AuthUserDeleteResponse-spec (s/keys :opt-un []))
(def AuthUserDeleteResponse-defaults {})

(defn cis->AuthUserDeleteResponse
  "CodedInputStream to AuthUserDeleteResponse"
  [is]
  (->> (tag-map AuthUserDeleteResponse-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->ResponseHeader is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthUserDeleteResponse)))

(defn ecis->AuthUserDeleteResponse
  "Embedded CodedInputStream to AuthUserDeleteResponse"
  [is]
  (cis->embedded cis->AuthUserDeleteResponse is))

(defn new-AuthUserDeleteResponse
  "Creates a new instance from a map, similar to map->AuthUserDeleteResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthUserDeleteResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthUserDeleteResponse-spec init))))]}
  (-> (merge AuthUserDeleteResponse-defaults init)
      (cond-> (contains? init :header) (update :header new-ResponseHeader))
      (map->AuthUserDeleteResponse)))

(defn pb->AuthUserDeleteResponse
  "Protobuf to AuthUserDeleteResponse"
  [input]
  (cis->AuthUserDeleteResponse (stream/new-cis input)))

;-----------------------------------------------------------------------------
; AuthRoleRevokePermissionRequest
;-----------------------------------------------------------------------------
(defrecord AuthRoleRevokePermissionRequest [role key range-end]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:role this) os)
    (write-String 2  {:optimize true} (:key this) os)
    (write-String 3  {:optimize true} (:range-end this) os)))

(s/def :etcdserverpb.messages.AuthRoleRevokePermissionRequest/role string?)
(s/def :etcdserverpb.messages.AuthRoleRevokePermissionRequest/key string?)
(s/def :etcdserverpb.messages.AuthRoleRevokePermissionRequest/range-end string?)
(s/def ::AuthRoleRevokePermissionRequest-spec (s/keys :opt-un [:etcdserverpb.messages.AuthRoleRevokePermissionRequest/role :etcdserverpb.messages.AuthRoleRevokePermissionRequest/key :etcdserverpb.messages.AuthRoleRevokePermissionRequest/range-end ]))
(def AuthRoleRevokePermissionRequest-defaults {:role "" :key "" :range-end "" })

(defn cis->AuthRoleRevokePermissionRequest
  "CodedInputStream to AuthRoleRevokePermissionRequest"
  [is]
  (->> (tag-map AuthRoleRevokePermissionRequest-defaults
         (fn [tag index]
             (case index
               1 [:role (cis->String is)]
               2 [:key (cis->String is)]
               3 [:range-end (cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->AuthRoleRevokePermissionRequest)))

(defn ecis->AuthRoleRevokePermissionRequest
  "Embedded CodedInputStream to AuthRoleRevokePermissionRequest"
  [is]
  (cis->embedded cis->AuthRoleRevokePermissionRequest is))

(defn new-AuthRoleRevokePermissionRequest
  "Creates a new instance from a map, similar to map->AuthRoleRevokePermissionRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AuthRoleRevokePermissionRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AuthRoleRevokePermissionRequest-spec init))))]}
  (-> (merge AuthRoleRevokePermissionRequest-defaults init)
      (map->AuthRoleRevokePermissionRequest)))

(defn pb->AuthRoleRevokePermissionRequest
  "Protobuf to AuthRoleRevokePermissionRequest"
  [input]
  (cis->AuthRoleRevokePermissionRequest (stream/new-cis input)))

